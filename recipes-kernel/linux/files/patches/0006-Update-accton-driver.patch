From ad4414698c1011db265a2e5fe4b88c13963f180c Mon Sep 17 00:00:00 2001
From: aken_liu <aken_liu@accton.com.tw>
Date: Sun, 5 Aug 2018 07:30:33 +0800
Subject: [PATCH 2/2] Update accton driver 1. fix the order of fan number with
 the new FAN CPLD. 2. fix the cold reset function with the new SYSTEM CPLD 3.
 update the MDEC control method that provided by hotta-san

---
 drivers/hwmon/accton_t600_cpld.c   | 30 ++++++++++++++++++++--------
 drivers/hwmon/accton_t600_fan.c    | 40 ++++++++++++++++++++++++++++++++------
 drivers/misc/accton_t600_fj_mdec.c | 31 ++++++++++++++++-------------
 3 files changed, 73 insertions(+), 28 deletions(-)

diff --git a/drivers/hwmon/accton_t600_cpld.c b/drivers/hwmon/accton_t600_cpld.c
index 68b3e58..51044c9 100644
--- a/drivers/hwmon/accton_t600_cpld.c
+++ b/drivers/hwmon/accton_t600_cpld.c
@@ -46,6 +46,7 @@
 #define BOARD_PG_REG                0x18
 #define PIU_MGMT_PG_REG             0x21
 #define SYSTEM_RESET_REG            0x22
+#define RESET_CONTROL_REG           0x26
 #define PIU_THERMAL_CONTROL_REG     0x19
 
 struct t600_cpld_data {
@@ -294,19 +295,32 @@ static ssize_t reset(struct device *dev, struct device_attribute *da,
         return status;
     }
         
-    if (reset < 1 || reset > 2) {  /* reset 1: cold reset, 2: warm reset */
+    if (reset < 1 || reset > 2) {  /* reset 1: hard reset, 2: warm reset */
         return -EINVAL;
     }
 
     mutex_lock(&data->update_lock);
-    status = t600_cpld_read(client, SYSTEM_RESET_REG);
-    if (unlikely(status < 0)) {
-        goto exit;
+    if (reset == 1) {
+        /* RESET_ALL when SW hard reset */
+        status = t600_cpld_read(client, SYSTEM_RESET_REG);
+        if (unlikely(status < 0)) {
+            goto exit;
+        }
+
+        regval = status | (0x1 << 0);
+        status = t600_cpld_write(client, RESET_CONTROL_REG, regval);
     }
-   
-    regval = status | reset;
+		else {
+        /* WARM_BOOT when SW warm reset */
+        status = t600_cpld_read(client, SYSTEM_RESET_REG);
+        if (unlikely(status < 0)) {
+            goto exit;
+        }
+
+        regval = status | (0x1 << 1);
+        status = t600_cpld_write(client, SYSTEM_RESET_REG, regval);
+		}
 
-    status = t600_cpld_write(client, SYSTEM_RESET_REG, regval);
     if (unlikely(status < 0)) {
         goto exit;
     }
@@ -331,7 +345,7 @@ static ssize_t show_bootstatus(struct device *dev, struct device_attribute *da,
         goto exit;
     }
     mutex_unlock(&data->update_lock);
-    return sprintf(buf, "%d\n", (status & 0x03));  /* BIT_1 WARM BOOT=2, BIT_0 COLD BOOT=1 */
+    return sprintf(buf, "%d\n", ((status & 0x02)? 2:1));  /* BIT_1 WARM BOOT=2, BIT_0 COLD BOOT=1 */
 exit:
     mutex_unlock(&data->update_lock);
     return status;  
diff --git a/drivers/hwmon/accton_t600_fan.c b/drivers/hwmon/accton_t600_fan.c
index 3e74c37..f116a60 100644
--- a/drivers/hwmon/accton_t600_fan.c
+++ b/drivers/hwmon/accton_t600_fan.c
@@ -469,22 +469,50 @@ static ssize_t fan_show_value(struct device *dev, struct device_attribute *da,
                 ret = sprintf(buf, "%u\n", duty_cycle);
                 break;
             }
-            case FAN_1_INPUT_ATTR_ID(1)...FAN_2_INPUT_ATTR_ID(5):           
-                ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[attr->index]));
+            case FAN_1_INPUT_ATTR_ID(1):
+                ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[FAN_1_INPUT_ATTR_ID(5)]));
                 break;
+            case FAN_1_INPUT_ATTR_ID(2):
+                ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[FAN_1_INPUT_ATTR_ID(4)]));
+                break;
+            case FAN_1_INPUT_ATTR_ID(3):
+                ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[FAN_1_INPUT_ATTR_ID(3)]));
+                break;
+            case FAN_1_INPUT_ATTR_ID(4):
+                ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[FAN_1_INPUT_ATTR_ID(2)]));
+                break;
+            case FAN_1_INPUT_ATTR_ID(5):
+                ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[FAN_1_INPUT_ATTR_ID(1)]));
+                break;
+            case FAN_2_INPUT_ATTR_ID(1):
+                ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[FAN_2_INPUT_ATTR_ID(5)]));
+                break;
+            case FAN_2_INPUT_ATTR_ID(2):
+                ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[FAN_2_INPUT_ATTR_ID(4)]));
+                break;
+            case FAN_2_INPUT_ATTR_ID(3):
+                ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[FAN_2_INPUT_ATTR_ID(3)]));
+                break;
+            case FAN_2_INPUT_ATTR_ID(4):
+                ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[FAN_2_INPUT_ATTR_ID(2)]));
+                break;
+            case FAN_2_INPUT_ATTR_ID(5):
+                ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[FAN_2_INPUT_ATTR_ID(1)]));
+                break;
+
             case FAN_DIRECTION_ATTR_ID(1)...FAN_DIRECTION_ATTR_ID(5):
                 ret = sprintf(buf, "%d\n", 
                               reg_val_to_direction(data->reg_val[FAN_DIRECTION_REG],
-                              attr->index - FAN_DIRECTION_ATTR_ID(1) ));
+                              FAN_DIRECTION_ATTR_ID(5) - attr->index));
                                                       
                 break;
             case FAN_PRESENT_ATTR_ID(1)...FAN_PRESENT_ATTR_ID(5):
                 ret = sprintf(buf, "%d\n",
                               reg_val_to_is_present(data->reg_val[FAN_PRESENT_REG],
-                              attr->index - FAN_PRESENT_ATTR_ID(1) ));                
+                              FAN_PRESENT_ATTR_ID(5) - attr->index));
                 break;
             case FAN_FAULT_ATTR_ID(1)...FAN_FAULT_ATTR_ID(5):
-                ret = sprintf(buf, "%d\n", is_fan_failed(data, attr->index - FAN_FAULT_ATTR_ID(1) ));
+                ret = sprintf(buf, "%d\n", is_fan_failed(data, FAN_FAULT_ATTR_ID(5) - attr->index));
                 break;
             case CPLD_VERSION:
                 ret = sprintf(buf, "%d\n", data->reg_val[CPLD_VERSION]);
@@ -493,7 +521,7 @@ static ssize_t fan_show_value(struct device *dev, struct device_attribute *da,
             case FAN_ENABLE_ATTR_ID(1)...FAN_ENABLE_ATTR_ID(5):
                 ret = sprintf(buf, "%d\n",
                               reg_val_to_is_enable(data->reg_val[FAN_ENABLE_REG],
-                              attr->index - FAN_ENABLE_ATTR_ID(1) ));
+                              FAN_ENABLE_ATTR_ID(5) - attr->index));
                 break;
 
             case FAN_WATCHDOG:
diff --git a/drivers/misc/accton_t600_fj_mdec.c b/drivers/misc/accton_t600_fj_mdec.c
index 35f5415..e877567 100644
--- a/drivers/misc/accton_t600_fj_mdec.c
+++ b/drivers/misc/accton_t600_fj_mdec.c
@@ -114,6 +114,7 @@ enum fpga_register_map
     // MDIO Error
     BMD_AC_BUS_TAERR    = 0x00700120,
     // MDEC HW Pin
+    HW_VCC              = 0x00000228,
     HW_ModSelL          = 0x00A00024,
     HW_LPMODE           = 0x00A00020,
     HW_RESETL           = 0x00A00008,
@@ -624,9 +625,6 @@ static void write_port_eeprom_one_byte(struct fpga_device* fpga_dev, u8 port, u8
     u32 set_add, set_dt, status;
     int i;
 
-    // Set ModSelL. Address is 0x00An0024. Port1:n=0x0~Port12:n=0xB
-    t600_fj_mdec_write32(0x1, fpga_dev->hw_addr + HW_ModSelL + (port << 16));
-
     for(i = 0; i < I2C_CHK_BUS_BUSY_RETRY_COUNT ; i++)
     {
         status = t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_BUSY + (port << 16)); //0x00An0130, n means port
@@ -671,10 +669,6 @@ static void write_port_eeprom_one_byte(struct fpga_device* fpga_dev, u8 port, u8
             printk(KERN_DEBUG "[DEBUG] check - I2C_IRQ_ERR_HL status is err, retry count =%d\r\n", i+1);
         }
     }
-
-    // Clear ModSelL. Address 0x00An0024. Port1:n=0x0~Port12:n=0xB
-    udelay(500); /* Fixme! We don't know how long should we delay */
-    t600_fj_mdec_write32(0x0, fpga_dev->hw_addr + HW_ModSelL + (port << 16));
 }
 
 static void read_port_eeprom_data(struct fpga_device* fpga_dev, u8 port, u8 *buffer)
@@ -697,9 +691,6 @@ static u8 read_port_eeprom_one_byte(struct fpga_device* fpga_dev, u8 port, u8 po
     u8 value;
     int i, j;
 
-    // Set ModSelL. Address is 0x00An0024. Port1:n=0x0~Port12:n=0xB
-    t600_fj_mdec_write32(0x1, fpga_dev->hw_addr + HW_ModSelL + (port << 16));
-
     for(i = 0; i < I2C_CHK_BUS_BUSY_RETRY_COUNT ; i++)
     {
         status = t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_BUSY + (port << 16)); //0x00An0130, n means port
@@ -743,8 +734,6 @@ static u8 read_port_eeprom_one_byte(struct fpga_device* fpga_dev, u8 port, u8 po
     
     value = (u8)t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_READ_DT + (port << 16)); //0x00An0144, n means port
 
-    // Clear ModSelL. Address 0x00An0024. Port1:n=0x0~Port12:n=0xB
-    t600_fj_mdec_write32(0x0, fpga_dev->hw_addr + HW_ModSelL + (port << 16));
     return value;   
 }
 
@@ -864,7 +853,7 @@ static int accton_fpga_probe(struct pci_dev* pdev, const struct pci_device_id* d
     struct fpga_device* fpga_dev;
     int pci_dev_busy = 0;
     int rc =  - EBUSY;
-
+    int i;
 
     dev_info(&pdev->dev, "%s v%s\n", DRIVER_DESCRIPTION_NAME, DRIVER_VERSION);
 
@@ -908,7 +897,21 @@ static int accton_fpga_probe(struct pci_dev* pdev, const struct pci_device_id* d
         goto err_out_free;
     }
 
-    /* Register sysfs hooks. */
+    /* T600 QSFP I2c access does not conflict. Set ModSelL. Always set ModSelL to 1.
+        Address is 0x00An0024. Port1:n=0x0~Port12:n=0xB */
+    for(i = 0; i < 12 ; i++)
+    {
+        t600_fj_mdec_write32(0x1, fpga_dev->hw_addr + HW_ModSelL + (i << 16));
+    }
+
+    /* Power on all port.
+       0: Power OFF(default)
+       1: Power ON
+       [0]: Port1 ~ [5]: Port6
+       [8]: Port7 ~ [13]: Port12
+    */
+    t600_fj_mdec_write32(0x00001F3F, fpga_dev->hw_addr + HW_VCC);
+
     rc = sysfs_create_group(&pdev->dev.kobj, &sysfs_group);
     if(rc)
     {
-- 
1.9.1

