From d4415f2a32ed835a2a88d0e46c232cef69d37553 Mon Sep 17 00:00:00 2001
From: aken_liu <aken_liu@edge-core.com.tw>
Date: Tue, 24 Jul 2018 20:52:48 +0800
Subject: [PATCH] update cpld/fan and mdec driver base on the new spec 1.bootup
 status and restart address 2.add thermal control node 3.fix PIU persent order
 4.add fan watchdog node 5.change the fan rpm/pwm calculation function
 6.update mdec access address 7.modify piu/qsfp eeprom read procedure

---
 drivers/hwmon/accton_t600_cpld.c   | 772 ++++++++++++++++++-----------------
 drivers/hwmon/accton_t600_fan.c    | 811 +++++++++++++++++++------------------
 drivers/misc/accton_t600_fj_mdec.c |  73 ++--
 3 files changed, 856 insertions(+), 800 deletions(-)

diff --git a/drivers/hwmon/accton_t600_cpld.c b/drivers/hwmon/accton_t600_cpld.c
index e29916c..68b3e58 100644
--- a/drivers/hwmon/accton_t600_cpld.c
+++ b/drivers/hwmon/accton_t600_cpld.c
@@ -34,17 +34,19 @@
 #include <linux/delay.h>
 
 #define DRVNAME "t600_cpld"
-#define I2C_RW_RETRY_COUNT			10
-#define I2C_RW_RETRY_INTERVAL			60 /* ms */
-#define BOARD_REV_REG				0x1
-#define CPLD_VER_REG				0x2
-#define PSU_STATUS_REG				0x3
-#define SFP_PWR_REG				0x14
-#define BOOT_STATUS_REG				0x22
-#define PIU_STATUS_REG				0x24
-#define USB_PG_REG				0x13
-#define BOARD_PG_REG				0x18
-#define PIU_MGMT_PG_REG				0x21
+#define I2C_RW_RETRY_COUNT          10
+#define I2C_RW_RETRY_INTERVAL       60 /* ms */
+#define BOARD_REV_REG               0x1
+#define CPLD_VER_REG                0x2
+#define PSU_STATUS_REG              0x3
+#define SFP_PWR_REG                 0x14
+#define BOOT_STATUS_REG             0x25
+#define PIU_STATUS_REG              0x24
+#define USB_PG_REG                  0x13
+#define BOARD_PG_REG                0x18
+#define PIU_MGMT_PG_REG             0x21
+#define SYSTEM_RESET_REG            0x22
+#define PIU_THERMAL_CONTROL_REG     0x19
 
 struct t600_cpld_data {
     struct device      *hwmon_dev;
@@ -55,37 +57,37 @@ struct t600_cpld_data {
  */
 static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
 
-#define PSU_PRESENT_ATTR_ID(index)		PSU##index##_PRESENT
-#define PSU_OUTPUTGOOD_ATTR_ID(index)  	PSU##index##_OUTPUT_GOOD
-#define PSU_ALARM_ATTR_ID(index)  		PSU##index##_ALARM
-#define PIU_PRESENT_ATTR_ID(index)	PIU##index##_PRESENT
-#define SFP_PWR_ATTR_ID(index)	        SFP##index##_PWR
+#define PSU_PRESENT_ATTR_ID(index)      PSU##index##_PRESENT
+#define PSU_OUTPUTGOOD_ATTR_ID(index)   PSU##index##_OUTPUT_GOOD
+#define PSU_ALARM_ATTR_ID(index)        PSU##index##_ALARM
+#define PIU_PRESENT_ATTR_ID(index)      PIU##index##_PRESENT
+#define SFP_PWR_ATTR_ID(index)          SFP##index##_PWR
 
 enum t600_cpld_sysfs_attributes {
-	BOARD_VERSION,
-	CPLD_VERSION,
-	ACCESS,
+    BOARD_VERSION,
+    CPLD_VERSION,
+    ACCESS,
     /* reset */
-        RESET,
-  /* bootup status */
-        BOOTUP_STATUS,
-	/* PSU attributes */
-  PSU_PRESENT_ATTR_ID(1),
-  PSU_PRESENT_ATTR_ID(2),
-  PSU_OUTPUTGOOD_ATTR_ID(1),
-  PSU_OUTPUTGOOD_ATTR_ID(2),
-  PSU_ALARM_ATTR_ID(1),
-  PSU_ALARM_ATTR_ID(2),  
-  /* PIU attributes */
-  PIU_PRESENT_ATTR_ID(1),
-  PIU_PRESENT_ATTR_ID(2),  
-  /* SFP attributes */
-  SFP_PWR_ATTR_ID(1),
-  SFP_PWR_ATTR_ID(2),  
-  USB_PWR_FAULT,
-  BOARD_PWR_GOOD,
-  PIU_MGMT_PWR_GOOD,
-     
+    RESET,
+    /* bootup status */
+    BOOTUP_STATUS,
+    /* PSU attributes */
+    PSU_PRESENT_ATTR_ID(1),
+    PSU_PRESENT_ATTR_ID(2),
+    PSU_OUTPUTGOOD_ATTR_ID(1),
+    PSU_OUTPUTGOOD_ATTR_ID(2),
+    PSU_ALARM_ATTR_ID(1),
+    PSU_ALARM_ATTR_ID(2),  
+    /* PIU attributes */
+    PIU_PRESENT_ATTR_ID(1),
+    PIU_PRESENT_ATTR_ID(2),  
+    /* SFP attributes */
+    SFP_PWR_ATTR_ID(1),
+    SFP_PWR_ATTR_ID(2),  
+    USB_PWR_FAULT,
+    BOARD_PWR_GOOD,
+    PIU_MGMT_PWR_GOOD,
+    PIU_THERMAL_CTRL
 };
 static ssize_t show_bootstatus(struct device *dev, struct device_attribute *da,
              char *buf);
@@ -95,26 +97,28 @@ static ssize_t show_sfp(struct device *dev, struct device_attribute *da,
              char *buf);                                   
 static ssize_t show_psu(struct device *dev, struct device_attribute *da,
              char *buf);
-static ssize_t show_reset_status(struct device *dev, struct device_attribute *da,
-             char *buf);
 static ssize_t reset(struct device *dev, struct device_attribute *da,
-			const char *buf, size_t count);
+            const char *buf, size_t count);
 static ssize_t raw_access(struct device *dev, struct device_attribute *da,
-			const char *buf, size_t count);		
+            const char *buf, size_t count);     
 static ssize_t show_version(struct device *dev, struct device_attribute *da,
              char *buf);             
 static ssize_t show_pwr_status(struct device *dev, struct device_attribute *da,
              char *buf);
 static ssize_t set_sfp_power(struct device *dev, struct device_attribute *da,
                         const char *buf, size_t count);
-
+static ssize_t show_thermal_ctrl(struct device *dev, struct device_attribute *da,
+             char *buf);
+static ssize_t set_thermal_ctrl(struct device *dev, struct device_attribute *da,
+                        const char *buf, size_t count);
+                        
 /* sysfs attributes for hwmon 
  */
 /* psu attributes */
 #define DECLARE_PSU_SENSOR_DEVICE_ATTR(index) \
-	static SENSOR_DEVICE_ATTR(psu##index##_present,    S_IRUGO, show_psu, NULL, PSU##index##_PRESENT); \
-	static SENSOR_DEVICE_ATTR(psu##index##_power_good, S_IRUGO, show_psu, NULL, PSU##index##_OUTPUT_GOOD); \
-	static SENSOR_DEVICE_ATTR(psu##index##_alarm, S_IRUGO, show_psu, 	 NULL, PSU##index##_ALARM)
+    static SENSOR_DEVICE_ATTR(psu##index##_present,    S_IRUGO, show_psu, NULL, PSU##index##_PRESENT); \
+    static SENSOR_DEVICE_ATTR(psu##index##_power_good, S_IRUGO, show_psu, NULL, PSU##index##_OUTPUT_GOOD); \
+    static SENSOR_DEVICE_ATTR(psu##index##_alarm, S_IRUGO, show_psu,     NULL, PSU##index##_ALARM)
 #define DECLARE_PSU_ATTR(index) \
     &sensor_dev_attr_psu##index##_present.dev_attr.attr, \
     &sensor_dev_attr_psu##index##_power_good.dev_attr.attr, \
@@ -122,8 +126,8 @@ static ssize_t set_sfp_power(struct device *dev, struct device_attribute *da,
     
 /* sfp attributes */
 #define DECLARE_SFP_SENSOR_DEVICE_ATTR(index) \
-	static SENSOR_DEVICE_ATTR(sfp##index##_pwr, S_IWUSR | S_IRUGO, show_sfp, set_sfp_power, SFP##index##_PWR)
-		
+    static SENSOR_DEVICE_ATTR(sfp##index##_pwr, S_IWUSR | S_IRUGO, show_sfp, set_sfp_power, SFP##index##_PWR)
+        
 #define DECLARE_SFP_ATTR(index) \
     &sensor_dev_attr_sfp##index##_pwr.dev_attr.attr    
     
@@ -136,9 +140,8 @@ static SENSOR_DEVICE_ATTR(usb_pwr_fault    , S_IRUGO, show_pwr_status, NULL, USB
 static SENSOR_DEVICE_ATTR(board_pwr_good   , S_IRUGO, show_pwr_status, NULL, BOARD_PWR_GOOD);
 static SENSOR_DEVICE_ATTR(piu_mgmt_pwr_good, S_IRUGO, show_pwr_status, NULL, PIU_MGMT_PWR_GOOD);
 
-
 /* reset attribtes */
-static SENSOR_DEVICE_ATTR(system_reset, S_IWUSR | S_IRUGO, show_reset_status, reset, RESET);
+static SENSOR_DEVICE_ATTR(system_reset, S_IWUSR, NULL, reset, RESET);
 /* boot status attribute */
 static SENSOR_DEVICE_ATTR(bootup_status, S_IRUGO, show_bootstatus, NULL, BOOTUP_STATUS);
 /* psu attributes*/
@@ -147,6 +150,8 @@ DECLARE_PSU_SENSOR_DEVICE_ATTR(2);
 /* piu present attribute */
 static SENSOR_DEVICE_ATTR(piu1_present, S_IRUGO, show_piu, NULL, PIU_PRESENT_ATTR_ID(1));
 static SENSOR_DEVICE_ATTR(piu2_present, S_IRUGO, show_piu, NULL, PIU_PRESENT_ATTR_ID(2));
+
+static SENSOR_DEVICE_ATTR(piu_thermal_ctrl, S_IRUGO | S_IWUSR, show_thermal_ctrl, set_thermal_ctrl, PIU_THERMAL_CTRL);
 /* sfp attributes*/
 DECLARE_SFP_SENSOR_DEVICE_ATTR(1);
 DECLARE_SFP_SENSOR_DEVICE_ATTR(2);
@@ -162,260 +167,236 @@ static struct attribute *t600_cpld_attributes[] = {
   /* psu attributes*/
   DECLARE_PSU_ATTR(1),
   DECLARE_PSU_ATTR(2),
-  /* piu present */	
+  /* piu present */ 
   &sensor_dev_attr_piu1_present.dev_attr.attr,
   &sensor_dev_attr_piu2_present.dev_attr.attr,
-  /* sfp attributes */	
+  /* sfp attributes */  
   DECLARE_SFP_ATTR(1),
   DECLARE_SFP_ATTR(2),
   &sensor_dev_attr_usb_pwr_fault.dev_attr.attr,
   &sensor_dev_attr_board_pwr_good.dev_attr.attr,
-  &sensor_dev_attr_piu_mgmt_pwr_good.dev_attr.attr,  
+  &sensor_dev_attr_piu_mgmt_pwr_good.dev_attr.attr,
+  &sensor_dev_attr_piu_thermal_ctrl.dev_attr.attr,  
   NULL
 };
 
 static const struct attribute_group t600_cpld_group = {
-	.attrs = t600_cpld_attributes,
+    .attrs = t600_cpld_attributes,
 };
 
 static int t600_cpld_read(struct i2c_client *client, u8 reg)
 {
-      int status = 0, retry = I2C_RW_RETRY_COUNT;
-      while (retry) {
-          status = i2c_smbus_read_byte_data(client, reg);
-          if (unlikely(status < 0)) {
-	     msleep(I2C_RW_RETRY_INTERVAL);
-	     retry--;
-	     continue;
-	 }
-	 break;
-      }
-      return status;
+    int status = 0, retry = I2C_RW_RETRY_COUNT;
+    while (retry) {
+        status = i2c_smbus_read_byte_data(client, reg);
+        if (unlikely(status < 0)) {
+            msleep(I2C_RW_RETRY_INTERVAL);
+            retry--;
+            continue;
+        }
+        break;
+    }
+    return status;
 }
 
 static int t600_cpld_write(struct i2c_client *client, u8 reg, u8 value)
 {
-	int status = 0, retry = I2C_RW_RETRY_COUNT;
-	while (retry) {
-           status = i2c_smbus_write_byte_data(client, reg, value);
-	   if (unlikely(status < 0)) {
-	          msleep(I2C_RW_RETRY_INTERVAL);
-		  retry--;
-		  continue;
-	   }
-	   break;
-	}
-        return status;
+    int status = 0, retry = I2C_RW_RETRY_COUNT;
+    while (retry) {
+        status = i2c_smbus_write_byte_data(client, reg, value);
+        if (unlikely(status < 0)) {
+            msleep(I2C_RW_RETRY_INTERVAL);
+            retry--;
+            continue;
+       }
+       break;
+    }
+    return status;
 }
 
 
 static ssize_t show_version(struct device *dev, struct device_attribute *da,
              char *buf)
 {
-        struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
-        int status = 0;
-
-	u8 reg = 0, mask = 0;
-        struct i2c_client *client = to_i2c_client(dev);
-        struct t600_cpld_data *data = i2c_get_clientdata(client);
-	switch (attr->index) {
-	case BOARD_VERSION:
-		reg  = BOARD_REV_REG;
-		mask = 0x07;
-		break;
-	case CPLD_VERSION:
-		reg  = CPLD_VER_REG;
-		mask = 0x0F;
-		break;
-	default:
-	        return 0; /* return 0 if attr->index is out of range */
-		break;
-	}
-        mutex_lock(&data->update_lock);
-	status = t600_cpld_read(client, reg);
-	if (unlikely(status < 0)) {
-		goto exit;
-	}
-	mutex_unlock(&data->update_lock);
-	return sprintf(buf, "%d\n", (status & mask));
+    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+    int status = 0;
+
+    u8 reg = 0, mask = 0;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_cpld_data *data = i2c_get_clientdata(client);
+    switch (attr->index) {
+    case BOARD_VERSION:
+        reg  = BOARD_REV_REG;
+        mask = 0x07;
+        break;
+    case CPLD_VERSION:
+        reg  = CPLD_VER_REG;
+        mask = 0x0F;
+        break;
+    default:
+        return 0; /* return 0 if attr->index is out of range */
+        break;
+    }
+    mutex_lock(&data->update_lock);
+    status = t600_cpld_read(client, reg);
+    if (unlikely(status < 0)) {
+        goto exit;
+    }
+    mutex_unlock(&data->update_lock);
+    return sprintf(buf, "%d\n", (status & mask));
 exit:
-	mutex_unlock(&data->update_lock);
-	return status;	
+    mutex_unlock(&data->update_lock);
+    return status;  
 
-	
+    
 }
 static ssize_t raw_access(struct device *dev, struct device_attribute *da,
-			const char *buf, size_t count)
+            const char *buf, size_t count)
 {
-	u32 addr, val;	
-        int status;
-        struct i2c_client *client = to_i2c_client(dev);
-        struct t600_cpld_data *data = i2c_get_clientdata(client);
-
-	if (sscanf(buf, "0x%x 0x%x", &addr, &val) != 2) {
-		return -EINVAL;
-	}
-
-	if (addr > 0xFF || val > 0xFF) {
-		return -EINVAL;
-	}
-
-	mutex_lock(&data->update_lock);
-	status = t600_cpld_write(client, addr, val);
-	if (unlikely(status < 0)) {
-		goto exit;
-	}
-	mutex_unlock(&data->update_lock);
-	return count;
+    u32 addr, val;  
+    int status;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_cpld_data *data = i2c_get_clientdata(client);
+
+    if (sscanf(buf, "0x%x 0x%x", &addr, &val) != 2) {
+        return -EINVAL;
+    }
+
+    if (addr > 0xFF || val > 0xFF) {
+        return -EINVAL;
+    }
+
+    mutex_lock(&data->update_lock);
+    status = t600_cpld_write(client, addr, val);
+    if (unlikely(status < 0)) {
+        goto exit;
+    }
+    mutex_unlock(&data->update_lock);
+    return count;
 exit:
-	mutex_unlock(&data->update_lock);
-	return status;	
+    mutex_unlock(&data->update_lock);
+    return status;  
 
 
 }
-//TBD Function
+
 static ssize_t reset(struct device *dev, struct device_attribute *da,
-			const char *buf, size_t count)
+            const char *buf, size_t count)
 {
-	int status, reset;
-	
-	u8 reg = 0, regval=0;
-        struct i2c_client *client = to_i2c_client(dev);
-        struct t600_cpld_data *data = i2c_get_clientdata(client);
-//        struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
-
-	status = kstrtoint(buf, 10, &reset);
-	if (status) {
-		return status;
-	}
-		
-	if (reset < 1 || reset > 2) {  // reset 1 means cold reset, 2 means warm reset 
-		                       // H/W comment add the R/W register  for "reset-all", "reset-CPU"
-		return -EINVAL;
-	}
-
-        //regval will depend on reset type to be set accordingly
-        //Might need to read the original one to modify too
-        //TBD        
-	status = t600_cpld_write(client, reg, regval);
-	if (unlikely(status < 0)) {
-		goto exit;
-	}
-	mutex_unlock(&data->update_lock);
-	return count;
+    int status, reset;
+    
+    u8 regval=0;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_cpld_data *data = i2c_get_clientdata(client);
 
-exit:
-	mutex_unlock(&data->update_lock);
-	return status;
-}
-//TBD Function
-static ssize_t show_reset_status(struct device *dev, struct device_attribute *da,
-             char *buf)
-{
+    status = kstrtoint(buf, 10, &reset);
+    if (status) {
+        return status;
+    }
+        
+    if (reset < 1 || reset > 2) {  /* reset 1: cold reset, 2: warm reset */
+        return -EINVAL;
+    }
 
-      int status = 0;
+    mutex_lock(&data->update_lock);
+    status = t600_cpld_read(client, SYSTEM_RESET_REG);
+    if (unlikely(status < 0)) {
+        goto exit;
+    }
+   
+    regval = status | reset;
 
-      struct i2c_client *client = to_i2c_client(dev);
-      struct t600_cpld_data *data = i2c_get_clientdata(client);
-      u8 reg = 0, mask = 0;
+    status = t600_cpld_write(client, SYSTEM_RESET_REG, regval);
+    if (unlikely(status < 0)) {
+        goto exit;
+    }
+    mutex_unlock(&data->update_lock);
+    return count;
 
-      mutex_lock(&data->update_lock);
-      status = t600_cpld_read(client, reg);   //H/W comment add the R/W register  for "reset-all", "reset-CPU"
-      if (unlikely(status < 0)) {
-		goto exit;
-      }
-      mutex_unlock(&data->update_lock);
-      //TBD need to read the R/W register and change the value to be return
-      
-      return sprintf(buf, "%d\n", (status & mask));
-       
 exit:
-      mutex_unlock(&data->update_lock);
-      return status;      
-
+    mutex_unlock(&data->update_lock);
+    return status;
 }
 
 static ssize_t show_bootstatus(struct device *dev, struct device_attribute *da,
              char *buf)
 {
-        int status = 0;
-
-        struct i2c_client *client = to_i2c_client(dev);
-        struct t600_cpld_data *data = i2c_get_clientdata(client);
-        mutex_lock(&data->update_lock);
-	status = t600_cpld_read(client, BOOT_STATUS_REG);
-	if (unlikely(status < 0)) {
-		goto exit;
-	}
-	mutex_unlock(&data->update_lock);
-	return sprintf(buf, "%d\n", (status & 0x03));  //BIT_1 WARM BOOT=2, BIT_0 COLD BOOT=1 
-exit:
-	mutex_unlock(&data->update_lock);
-	return status;	
-
+    int status = 0;
 
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_cpld_data *data = i2c_get_clientdata(client);
+    mutex_lock(&data->update_lock);
+    status = t600_cpld_read(client, BOOT_STATUS_REG);
+    if (unlikely(status < 0)) {
+        goto exit;
+    }
+    mutex_unlock(&data->update_lock);
+    return sprintf(buf, "%d\n", (status & 0x03));  /* BIT_1 WARM BOOT=2, BIT_0 COLD BOOT=1 */
+exit:
+    mutex_unlock(&data->update_lock);
+    return status;  
 }
 static ssize_t show_psu(struct device *dev, struct device_attribute *da,
              char *buf)
 {
-      int value = 0;
-      struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+    int value = 0;
+    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
          
-      int status = 0, mask = 0; 
-      struct i2c_client *client = to_i2c_client(dev);
-      struct t600_cpld_data *data = i2c_get_clientdata(client);
-      mutex_lock(&data->update_lock);
-      status = t600_cpld_read(client, PSU_STATUS_REG);
-      if (unlikely(status < 0)) {
-	  goto exit;
-      }
-      mutex_unlock(&data->update_lock);
-
-      switch (attr->index) {
-	      case PSU1_PRESENT:
-	      case PSU2_PRESENT:
-			if (attr->index - PSU1_PRESENT) 
-			    mask = 0x1; 
-			else
-			    mask = 0x8;			
-			if (status & mask)
-	                   value = 0;
-	                else
-	                   value = 1;    /* cpld val=0: present*/
-	                break;  	
-	      case PSU1_OUTPUT_GOOD:
-	      case PSU2_OUTPUT_GOOD:
-			if (attr->index - PSU1_OUTPUT_GOOD) 
-			    mask = 0x2; 
-			else
-			    mask = 0x10;
-			    
-			if (status & mask)
-	                   value = 1;
-	                else
-	                   value = 0;	
-			break;
-	      case PSU1_ALARM:
-	      case PSU2_ALARM:
-			if (attr->index - PSU1_ALARM) 
-			    mask = 0x4; 
-			else
-			    mask = 0x20;			    
-			if (status & mask)
-	                    value = 0;  /* cpld val=1: PSU works normal */
-	                else
-	                    value = 1;
-			    
-			break;
-	      default:
-			return 0;
-	}
-			    	    
-        return sprintf(buf, "%d\n", value);
+    int status = 0, mask = 0; 
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_cpld_data *data = i2c_get_clientdata(client);
+    mutex_lock(&data->update_lock);
+    status = t600_cpld_read(client, PSU_STATUS_REG);
+    if (unlikely(status < 0)) {
+        goto exit;
+    }
+    mutex_unlock(&data->update_lock);
+
+    switch (attr->index) {
+        case PSU1_PRESENT:
+        case PSU2_PRESENT:
+            if (attr->index - PSU1_PRESENT) 
+                mask = 0x1; 
+            else
+                mask = 0x8;         
+            if (status & mask)
+                value = 0;
+            else
+                value = 1;    /* cpld val=0: present*/
+            break;      
+        case PSU1_OUTPUT_GOOD:
+        case PSU2_OUTPUT_GOOD:
+            if (attr->index - PSU1_OUTPUT_GOOD) 
+                mask = 0x2; 
+            else
+                mask = 0x10;
+                
+            if (status & mask)
+                value = 1;
+            else
+                value = 0;   
+            break;
+        case PSU1_ALARM:
+        case PSU2_ALARM:
+            if (attr->index - PSU1_ALARM) 
+                mask = 0x4; 
+            else
+                mask = 0x20;                
+            if (status & mask)
+                value = 0;  /* cpld val=1: PSU works normal */
+            else
+                value = 1;
+                
+            break;
+          default:
+            return 0;
+    }
+                        
+    return sprintf(buf, "%d\n", value);
 exit:
-	mutex_unlock(&data->update_lock);
-	return status;
-	
+    mutex_unlock(&data->update_lock);
+    return status;
+    
 }
 
 static ssize_t show_piu(struct device *dev, struct device_attribute *da
@@ -429,17 +410,17 @@ static ssize_t show_piu(struct device *dev, struct device_attribute *da
     mutex_lock(&data->update_lock);
     status = t600_cpld_read(client, PIU_STATUS_REG);
     if (unlikely(status < 0)) {
-		goto exit;
+        goto exit;
     }
     mutex_unlock(&data->update_lock);
 
     switch (attr->index) {
-	    case PIU1_PRESENT:
-	    case PIU2_PRESENT:
-		 value = !(status >> (1-(attr->index - PIU1_PRESENT)) & 0x1);
-		 break;;
-	    default:
-		return 0;
+        case PIU1_PRESENT:
+        case PIU2_PRESENT:
+            value = !((status >> (attr->index - PIU1_PRESENT)) & 0x1);
+            break;;
+        default:
+        return 0;
     }
     return sprintf(buf, "%d\n", value);
 
@@ -449,6 +430,74 @@ exit:
 
 }
 
+static ssize_t show_thermal_ctrl(struct device *dev, struct device_attribute *da
+                        ,char *buf)
+{
+    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_cpld_data *data = i2c_get_clientdata(client);
+    int value = 0, status = 0; 
+    
+    mutex_lock(&data->update_lock);
+    status = t600_cpld_read(client, PIU_THERMAL_CONTROL_REG);
+    if (unlikely(status < 0)) {
+        goto exit;
+    }
+    mutex_unlock(&data->update_lock);
+
+    value = (status >> 2) & 0x3;
+
+    return sprintf(buf, "%d\n", value);
+
+exit:
+    mutex_unlock(&data->update_lock);
+    return status;     
+
+}
+
+static ssize_t set_thermal_ctrl(struct device *dev, struct device_attribute *da,
+                        const char *buf, size_t count)
+{
+    int status = 0, thermal_ctrl = 0;
+    u8 regval=0;
+    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_cpld_data *data = i2c_get_clientdata(client);
+
+    status = kstrtoint(buf, 10, &thermal_ctrl);
+    if (status) {
+        return status;
+    }
+
+    if ((thermal_ctrl != 0) && (thermal_ctrl != 3)) {
+        return -EINVAL;
+    }
+
+    mutex_lock(&data->update_lock);
+
+    status = t600_cpld_read(client, PIU_THERMAL_CONTROL_REG);
+    if (unlikely(status < 0)) {
+        goto exit;
+    }
+
+    if (thermal_ctrl == 3)   /* Bit2~3, 0: MDEC/DCO control, 1: CPU control */
+        regval = status | 0xC;
+    else
+        regval = status & (~0xC);
+
+    status = t600_cpld_write(client, PIU_THERMAL_CONTROL_REG, regval);
+    if (unlikely(status < 0)) {
+        goto exit;
+    }
+
+    mutex_unlock(&data->update_lock);
+    return count;
+
+exit:
+    mutex_unlock(&data->update_lock);
+    return status;
+}
+
 static ssize_t show_sfp(struct device *dev, struct device_attribute *da,
              char *buf)
 {
@@ -461,43 +510,41 @@ static ssize_t show_sfp(struct device *dev, struct device_attribute *da,
     u8 reg=0;
     
     switch (attr->index) {
-	case SFP1_PWR:  /* BIT_1 SFP1_PWR BIT_2 SFP2_PWR */ 
-	case SFP2_PWR:
-	   if (attr->index - SFP1_PWR) 
-	       mask = 0x04; 
-	   else
-	       mask = 0x02;
-	   reg = SFP_PWR_REG;
-	   break;
-
-	default:
-	   return 0;
-	   break;
+    case SFP1_PWR:  /* BIT_1 SFP1_PWR BIT_2 SFP2_PWR */ 
+    case SFP2_PWR:
+        if (attr->index - SFP1_PWR) 
+            mask = 0x04; 
+        else
+            mask = 0x02;
+        reg = SFP_PWR_REG;
+        break;
+
+    default:
+        return 0;
+        break;
     }
     mutex_lock(&data->update_lock);
     status = t600_cpld_read(client, reg);
     if (unlikely(status < 0)) {
-	goto exit;
+        goto exit;
     }
     mutex_unlock(&data->update_lock);
     if (status & mask)
-	  value = 1;
+        value = 1;
     else
-	  value = 0;	       	       
-	    
+        value = 0;                   
+        
     return sprintf(buf, "%d\n", value);
 exit:
     mutex_unlock(&data->update_lock);
-    return status;    
-   
-
+    return status;
 }
 
 static ssize_t set_sfp_power(struct device *dev, struct device_attribute *da,
                         const char *buf, size_t count)
 {
-    int status = 0, sfp_power = 0;
-    u8 reg = 0, regval=0, mask = 0;
+    int status = 0, sfp_power = 0, mask = 0;
+    u8 reg = 0, regval=0;
     struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
     struct i2c_client *client = to_i2c_client(dev);
     struct t600_cpld_data *data = i2c_get_clientdata(client);
@@ -508,22 +555,22 @@ static ssize_t set_sfp_power(struct device *dev, struct device_attribute *da,
     }
 
     if (sfp_power != 0 && sfp_power != 1) {
-            return -EINVAL;
+        return -EINVAL;
     }
 
     switch (attr->index) {
         case SFP1_PWR:  /* BIT_1 SFP1_PWR BIT_2 SFP2_PWR */
         case SFP2_PWR:
-           if (attr->index - SFP1_PWR)
-               mask = 0x04;
-           else
-               mask = 0x02;
-           reg = SFP_PWR_REG;
-           break;
+            if (attr->index - SFP1_PWR)
+                mask = 0x04;
+            else
+                mask = 0x02;
+            reg = SFP_PWR_REG;
+            break;
 
         default:
-           return 0;
-           break;
+            return 0;
+            break;
     }
 
     mutex_lock(&data->update_lock);
@@ -555,82 +602,80 @@ exit:
 static ssize_t show_pwr_status(struct device *dev, struct device_attribute *da,
              char *buf)
 {
-        struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
-        int status = 0;
-
-	u8 reg = 0, mask = 0;
-        struct i2c_client *client = to_i2c_client(dev);
-        struct t600_cpld_data *data = i2c_get_clientdata(client);
-	switch (attr->index) {
-	case USB_PWR_FAULT:
-		reg  = USB_PG_REG;
-		mask = 0x01;
-		break;
-	case BOARD_PWR_GOOD:
-		reg  = BOARD_PG_REG;
-		mask = 0x01;
-		break;
-	case PIU_MGMT_PWR_GOOD:
-		reg  = PIU_MGMT_PG_REG;
-		mask = 0x01;
-		break;		
-	default:
-	        return 0;
-		break;
-	}
-        mutex_lock(&data->update_lock);
-	status = t600_cpld_read(client, reg);
-	if (unlikely(status < 0)) {
-		goto exit;
-	}
-	mutex_unlock(&data->update_lock);	
-	if (USB_PG_REG == reg)
-	   return sprintf(buf, "%d\n", !(status & mask)); // read 0 is usb_pwr_fault T, 1 usb_pwr_fault F
-	else
-	   return sprintf(buf, "%d\n", (status & mask));
-exit:
-	mutex_unlock(&data->update_lock);
-	return status;	
+    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+    int status = 0;
 
-	
+    u8 reg = 0, mask = 0;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_cpld_data *data = i2c_get_clientdata(client);
+    switch (attr->index) {
+    case USB_PWR_FAULT:
+        reg  = USB_PG_REG;
+        mask = 0x01;
+        break;
+    case BOARD_PWR_GOOD:
+        reg  = BOARD_PG_REG;
+        mask = 0x01;
+        break;
+    case PIU_MGMT_PWR_GOOD:
+        reg  = PIU_MGMT_PG_REG;
+        mask = 0x01;
+        break;      
+    default:
+        return 0;
+        break;
+    }
+    mutex_lock(&data->update_lock);
+    status = t600_cpld_read(client, reg);
+    if (unlikely(status < 0)) {
+        goto exit;
+    }
+    mutex_unlock(&data->update_lock);   
+    if (USB_PG_REG == reg)
+       return sprintf(buf, "%d\n", !(status & mask)); // read 0 is usb_pwr_fault T, 1 usb_pwr_fault F
+    else
+       return sprintf(buf, "%d\n", (status & mask));
+exit:
+    mutex_unlock(&data->update_lock);
+    return status;  
 }
 
 static int t600_cpld_probe(struct i2c_client *client,
             const struct i2c_device_id *dev_id)
 {
-  int status;
-  struct t600_cpld_data *data = NULL;
-
-  if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
-      dev_dbg(&client->dev, "i2c_check_functionality failed (0x%x)\n", client->addr);
-      status = -EIO;
-      goto exit;
-  }
-
-  data = kzalloc(sizeof(struct t600_cpld_data), GFP_KERNEL);
-  if (!data) {
-      status = -ENOMEM;
-      goto exit;
-  }
-
-  i2c_set_clientdata(client, data);
-  mutex_init(&data->update_lock);
-  dev_info(&client->dev, "chip found\n");
-
-   /* Register sysfs hooks */
-   status = sysfs_create_group(&client->dev.kobj, &t600_cpld_group);
-   if (status) {
-	goto exit_free;
-   }
-
-   data->hwmon_dev = hwmon_device_register(&client->dev);
-   if (IS_ERR(data->hwmon_dev)) {
-	status = PTR_ERR(data->hwmon_dev);
-	goto exit_remove;
-   }
+    int status;
+    struct t600_cpld_data *data = NULL;
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+        dev_dbg(&client->dev, "i2c_check_functionality failed (0x%x)\n", client->addr);
+        status = -EIO;
+        goto exit;
+    }
+
+    data = kzalloc(sizeof(struct t600_cpld_data), GFP_KERNEL);
+    if (!data) {
+        status = -ENOMEM;
+        goto exit;
+    }
+
+    i2c_set_clientdata(client, data);
+    mutex_init(&data->update_lock);
+    dev_info(&client->dev, "chip found\n");
+
+    /* Register sysfs hooks */
+    status = sysfs_create_group(&client->dev.kobj, &t600_cpld_group);
+    if (status) {
+        goto exit_free;
+    }
+
+    data->hwmon_dev = hwmon_device_register(&client->dev);
+    if (IS_ERR(data->hwmon_dev)) {
+        status = PTR_ERR(data->hwmon_dev);
+        goto exit_remove;
+    }
 
    dev_info(&client->dev, "%s: cpld '%s'\n",
-		 dev_name(data->hwmon_dev), client->name);
+         dev_name(data->hwmon_dev), client->name);
 
     return 0;
 
@@ -645,13 +690,13 @@ exit:
 
 static int t600_cpld_remove(struct i2c_client *client)
 {
-  struct t600_cpld_data *data = i2c_get_clientdata(client);
+    struct t600_cpld_data *data = i2c_get_clientdata(client);
 
-  hwmon_device_unregister(data->hwmon_dev);
-  sysfs_remove_group(&client->dev.kobj, &t600_cpld_group);
-  kfree(data);
+    hwmon_device_unregister(data->hwmon_dev);
+    sysfs_remove_group(&client->dev.kobj, &t600_cpld_group);
+    kfree(data);
 
-  return 0;
+    return 0;
 }
 
 static const struct i2c_device_id t600_cpld_id[] = {
@@ -676,4 +721,3 @@ module_i2c_driver(t600_cpld_driver);
 MODULE_AUTHOR("Vic Lin <vic_lin@accton.com.tw>");
 MODULE_DESCRIPTION("t600 cpld driver");
 MODULE_LICENSE("GPL");
-
diff --git a/drivers/hwmon/accton_t600_fan.c b/drivers/hwmon/accton_t600_fan.c
index b96b282..3e74c37 100644
--- a/drivers/hwmon/accton_t600_fan.c
+++ b/drivers/hwmon/accton_t600_fan.c
@@ -32,130 +32,132 @@
 
 #define DRVNAME "t600_fan"
 
-static struct t600_fan_data *t600_fan_update_device(struct device *dev);					
+static struct t600_fan_data *t600_fan_update_device(struct device *dev);                    
 static ssize_t fan_show_value(struct device *dev, struct device_attribute *da, char *buf);
 static ssize_t set_duty_cycle(struct device *dev, struct device_attribute *da,
-			const char *buf, size_t count);
+            const char *buf, size_t count);
 
 static ssize_t set_fan_enable(struct device *dev, struct device_attribute *da,
-			const char *buf, size_t count);
-
+            const char *buf, size_t count);
+static ssize_t set_fan_watchdog(struct device *dev, struct device_attribute *da, const char *buf, size_t count);
 static ssize_t raw_access(struct device *dev, struct device_attribute *da,
-			const char *buf, size_t count);				
-			
+            const char *buf, size_t count);             
+            
 /* fan related data, the index should match sysfs_fan_attributes */
 static const u8 fan_reg[] = {
-	0x01,      /* fan cpld version */
-	0x0F,	   /* fan 1-6 present status */
-	0x10,	   /* fan 1-6 direction(0:B2F 1:F2B) */
-	0x11,	   /* fan PWM(for all fan) */
-	0x12,	   /* front fan 1 speed(rpm) */
-	0x13,	   /* front fan 2 speed(rpm) */
-	0x14,	   /* front fan 3 speed(rpm) */
-	0x15,	   /* front fan 4 speed(rpm) */
-	0x16,	   /* front fan 5 speed(rpm) */
-	0x22,	   /* rear fan 1 speed(rpm) */
-	0x23,	   /* rear fan 2 speed(rpm) */
-	0x24,	   /* rear fan 3 speed(rpm) */
-	0x25,	   /* rear fan 4 speed(rpm) */
-	0x26,	   /* rear fan 5 speed(rpm) */
-	0x30,      /* fan power enable */
+    0x01,      /* fan cpld version */
+    0x0F,      /* fan 1-6 present status */
+    0x10,      /* fan 1-6 direction(0:B2F 1:F2B) */
+    0x11,      /* fan PWM(for all fan) */
+    0x12,      /* front fan 1 speed(rpm) */
+    0x13,      /* front fan 2 speed(rpm) */
+    0x14,      /* front fan 3 speed(rpm) */
+    0x15,      /* front fan 4 speed(rpm) */
+    0x16,      /* front fan 5 speed(rpm) */
+    0x22,      /* rear fan 1 speed(rpm) */
+    0x23,      /* rear fan 2 speed(rpm) */
+    0x24,      /* rear fan 3 speed(rpm) */
+    0x25,      /* rear fan 4 speed(rpm) */
+    0x26,      /* rear fan 5 speed(rpm) */
+    0x30,      /* fan power enable */
+    0x33       /* fan watchdog */
 };
 
 /* Each client has this additional data */
 struct t600_fan_data {
-	struct device   *hwmon_dev;
-	struct mutex	 update_lock;
-	char		valid;		   /* != 0 if registers are valid */
-	unsigned long	last_updated;	/* In jiffies */
-	u8		reg_val[ARRAY_SIZE(fan_reg)]; /* Register value */
+    struct device   *hwmon_dev;
+    struct mutex     update_lock;
+    char        valid;         /* != 0 if registers are valid */
+    unsigned long   last_updated;   /* In jiffies */
+    u8      reg_val[ARRAY_SIZE(fan_reg)]; /* Register value */
 };
 
-#define FAN_PRESENT_ATTR_ID(index)		FAN##index##_PRESENT
-#define FAN_ENABLE_ATTR_ID(index)		FAN##index##_ENABLE
-#define FAN_FAULT_ATTR_ID(index)		FAN##index##_FAULT
-#define FAN_1_INPUT_ATTR_ID(index)		FAN##index##_1_INPUT
-#define FAN_2_INPUT_ATTR_ID(index)		FAN##index##_2_INPUT
-#define FAN_DIRECTION_ATTR_ID(index)            FAN##index##_DIRECTION
+#define FAN_PRESENT_ATTR_ID(index)      FAN##index##_PRESENT
+#define FAN_ENABLE_ATTR_ID(index)       FAN##index##_ENABLE
+#define FAN_FAULT_ATTR_ID(index)        FAN##index##_FAULT
+#define FAN_1_INPUT_ATTR_ID(index)      FAN##index##_1_INPUT
+#define FAN_2_INPUT_ATTR_ID(index)      FAN##index##_2_INPUT
+#define FAN_DIRECTION_ATTR_ID(index)    FAN##index##_DIRECTION
 
 enum fan_id {
-	FAN1_ID,
-	FAN2_ID,
-	FAN3_ID,
-	FAN4_ID,
-	FAN5_ID,
-	NUM_OF_FAN
+    FAN1_ID,
+    FAN2_ID,
+    FAN3_ID,
+    FAN4_ID,
+    FAN5_ID,
+    NUM_OF_FAN
 };
 enum sysfs_fan_attributes {
-	CPLD_VERSION,           /* fan cpld version */
-	FAN_PRESENT_REG,
-	FAN_DIRECTION_REG,
-	FAN_PWM1,	        /* FAN PWM (for all fan) */	
-	FAN_1_INPUT_ATTR_ID(1),	/* front fan X speed(rpm) */
-	FAN_1_INPUT_ATTR_ID(2),
-	FAN_1_INPUT_ATTR_ID(3),
-	FAN_1_INPUT_ATTR_ID(4),
-	FAN_1_INPUT_ATTR_ID(5),
-	FAN_2_INPUT_ATTR_ID(1),	/* rear fan X speed(rpm) */
-	FAN_2_INPUT_ATTR_ID(2),
-	FAN_2_INPUT_ATTR_ID(3),
-	FAN_2_INPUT_ATTR_ID(4),
-	FAN_2_INPUT_ATTR_ID(5),		
-	FAN_ENABLE_REG,
-	ACCESS,	                /* access cpld register */	
-	FAN_ENABLE_ATTR_ID(1),  /* FAN X control switch */
-	FAN_ENABLE_ATTR_ID(2),
-	FAN_ENABLE_ATTR_ID(3),
-	FAN_ENABLE_ATTR_ID(4),
-	FAN_ENABLE_ATTR_ID(5),
-	FAN_FAULT_ATTR_ID(1),	/* FAN X fault status */
-	FAN_FAULT_ATTR_ID(2),
-	FAN_FAULT_ATTR_ID(3),
-	FAN_FAULT_ATTR_ID(4),
-	FAN_FAULT_ATTR_ID(5),
-        FAN_PRESENT_ATTR_ID(1), /* fan X present */
-        FAN_PRESENT_ATTR_ID(2),
-        FAN_PRESENT_ATTR_ID(3),
-        FAN_PRESENT_ATTR_ID(4),
-        FAN_PRESENT_ATTR_ID(5),
-        FAN_DIRECTION_ATTR_ID(1), /* fan X direction*/
-        FAN_DIRECTION_ATTR_ID(2),
-        FAN_DIRECTION_ATTR_ID(3),
-        FAN_DIRECTION_ATTR_ID(4),
-        FAN_DIRECTION_ATTR_ID(5)
+    CPLD_VERSION,           /* fan cpld version */
+    FAN_PRESENT_REG,
+    FAN_DIRECTION_REG,
+    FAN_PWM1,               /* FAN PWM (for all fan) */ 
+    FAN_1_INPUT_ATTR_ID(1), /* front fan X speed(rpm) */
+    FAN_1_INPUT_ATTR_ID(2),
+    FAN_1_INPUT_ATTR_ID(3),
+    FAN_1_INPUT_ATTR_ID(4),
+    FAN_1_INPUT_ATTR_ID(5),
+    FAN_2_INPUT_ATTR_ID(1), /* rear fan X speed(rpm) */
+    FAN_2_INPUT_ATTR_ID(2),
+    FAN_2_INPUT_ATTR_ID(3),
+    FAN_2_INPUT_ATTR_ID(4),
+    FAN_2_INPUT_ATTR_ID(5),     
+    FAN_ENABLE_REG,
+    FAN_WATCHDOG,
+    ACCESS,                 /* access cpld register */  
+    FAN_ENABLE_ATTR_ID(1),  /* FAN X control switch */
+    FAN_ENABLE_ATTR_ID(2),
+    FAN_ENABLE_ATTR_ID(3),
+    FAN_ENABLE_ATTR_ID(4),
+    FAN_ENABLE_ATTR_ID(5),
+    FAN_FAULT_ATTR_ID(1),   /* FAN X fault status */
+    FAN_FAULT_ATTR_ID(2),
+    FAN_FAULT_ATTR_ID(3),
+    FAN_FAULT_ATTR_ID(4),
+    FAN_FAULT_ATTR_ID(5),
+    FAN_PRESENT_ATTR_ID(1), /* fan X present */
+    FAN_PRESENT_ATTR_ID(2),
+    FAN_PRESENT_ATTR_ID(3),
+    FAN_PRESENT_ATTR_ID(4),
+    FAN_PRESENT_ATTR_ID(5),
+    FAN_DIRECTION_ATTR_ID(1), /* fan X direction*/
+    FAN_DIRECTION_ATTR_ID(2),
+    FAN_DIRECTION_ATTR_ID(3),
+    FAN_DIRECTION_ATTR_ID(4),
+    FAN_DIRECTION_ATTR_ID(5)
 };
 
 /* Define attributes */
 #define DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(index) \
-	static SENSOR_DEVICE_ATTR(fan##index##_fault, S_IRUGO, fan_show_value, NULL, FAN##index##_FAULT)
-#define DECLARE_FAN_FAULT_ATTR(index)	  &sensor_dev_attr_fan##index##_fault.dev_attr.attr
+    static SENSOR_DEVICE_ATTR(fan##index##_fault, S_IRUGO, fan_show_value, NULL, FAN##index##_FAULT)
+#define DECLARE_FAN_FAULT_ATTR(index)     &sensor_dev_attr_fan##index##_fault.dev_attr.attr
 
 #define DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(index) \
-	static SENSOR_DEVICE_ATTR(fan##index##_direction, S_IRUGO, fan_show_value, NULL, FAN##index##_DIRECTION)
+    static SENSOR_DEVICE_ATTR(fan##index##_direction, S_IRUGO, fan_show_value, NULL, FAN##index##_DIRECTION)
 #define DECLARE_FAN_DIRECTION_ATTR(index)  &sensor_dev_attr_fan##index##_direction.dev_attr.attr
 
 #define DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(index) \
-	static SENSOR_DEVICE_ATTR(fan##index##_present, S_IRUGO, fan_show_value, NULL, FAN##index##_PRESENT)
-#define DECLARE_FAN_PRESENT_ATTR(index)	  &sensor_dev_attr_fan##index##_present.dev_attr.attr
+    static SENSOR_DEVICE_ATTR(fan##index##_present, S_IRUGO, fan_show_value, NULL, FAN##index##_PRESENT)
+#define DECLARE_FAN_PRESENT_ATTR(index)   &sensor_dev_attr_fan##index##_present.dev_attr.attr
 
 #define DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(index) \
-	static SENSOR_DEVICE_ATTR(fan##index##_1_input, S_IRUGO, fan_show_value, NULL, FAN##index##_1_INPUT);\
-	static SENSOR_DEVICE_ATTR(fan##index##_2_input, S_IRUGO, fan_show_value, NULL, FAN##index##_2_INPUT)
+    static SENSOR_DEVICE_ATTR(fan##index##_1_input, S_IRUGO, fan_show_value, NULL, FAN##index##_1_INPUT);\
+    static SENSOR_DEVICE_ATTR(fan##index##_2_input, S_IRUGO, fan_show_value, NULL, FAN##index##_2_INPUT)
 #define DECLARE_FAN_SPEED_RPM_ATTR(index)  &sensor_dev_attr_fan##index##_1_input.dev_attr.attr, \
-	  								   &sensor_dev_attr_fan##index##_2_input.dev_attr.attr
+                                       &sensor_dev_attr_fan##index##_2_input.dev_attr.attr
 
 static SENSOR_DEVICE_ATTR(cpld_version, S_IRUGO, fan_show_value, NULL, CPLD_VERSION);
-
+static SENSOR_DEVICE_ATTR(fan_watchdog, S_IWUSR | S_IRUGO, fan_show_value, set_fan_watchdog, FAN_WATCHDOG);
 static SENSOR_DEVICE_ATTR(raw_access, S_IWUSR | S_IRUGO, NULL, raw_access, ACCESS);
 
 #define DECLARE_FAN_DUTY_CYCLE_SENSOR_DEV_ATTR(index) \
-	static SENSOR_DEVICE_ATTR(pwm##index, S_IWUSR | S_IRUGO, fan_show_value, set_duty_cycle, FAN_PWM1)
+    static SENSOR_DEVICE_ATTR(pwm##index, S_IWUSR | S_IRUGO, fan_show_value, set_duty_cycle, FAN_PWM1)
 #define DECLARE_FAN_DUTY_CYCLE_ATTR(index) &sensor_dev_attr_pwm##index.dev_attr.attr
 
 /* fanX enable attribute */
 #define DECLARE_FAN_ENABLE_SENSOR_DEV_ATTR(index) \
-	static SENSOR_DEVICE_ATTR(fan##index##_enable, S_IWUSR | S_IRUGO, fan_show_value, set_fan_enable, FAN##index##_ENABLE)
-#define DECLARE_FAN_ENABLE_ATTR(index)	  &sensor_dev_attr_fan##index##_enable.dev_attr.attr
+    static SENSOR_DEVICE_ATTR(fan##index##_enable, S_IWUSR | S_IRUGO, fan_show_value, set_fan_enable, FAN##index##_ENABLE)
+#define DECLARE_FAN_ENABLE_ATTR(index)    &sensor_dev_attr_fan##index##_enable.dev_attr.attr
 
 
 /* 5 fan fault attributes in this platform */
@@ -192,76 +194,77 @@ DECLARE_FAN_ENABLE_SENSOR_DEV_ATTR(4);
 DECLARE_FAN_ENABLE_SENSOR_DEV_ATTR(5);
 
 static struct attribute *t600_fan_attributes[] = {
-	&sensor_dev_attr_cpld_version.dev_attr.attr,
-	&sensor_dev_attr_raw_access.dev_attr.attr,	
-	DECLARE_FAN_ENABLE_ATTR(1),
-	DECLARE_FAN_ENABLE_ATTR(2),
-	DECLARE_FAN_ENABLE_ATTR(3),
-	DECLARE_FAN_ENABLE_ATTR(4),
-	DECLARE_FAN_ENABLE_ATTR(5),	
-	DECLARE_FAN_DUTY_CYCLE_ATTR(1),	
-	/* fan related attributes */
-	DECLARE_FAN_FAULT_ATTR(1),
-	DECLARE_FAN_FAULT_ATTR(2),
-	DECLARE_FAN_FAULT_ATTR(3),
-	DECLARE_FAN_FAULT_ATTR(4),
-	DECLARE_FAN_FAULT_ATTR(5),
-	DECLARE_FAN_DIRECTION_ATTR(1),
-	DECLARE_FAN_DIRECTION_ATTR(2),
-	DECLARE_FAN_DIRECTION_ATTR(3),
-	DECLARE_FAN_DIRECTION_ATTR(4),
-	DECLARE_FAN_DIRECTION_ATTR(5),
-	DECLARE_FAN_SPEED_RPM_ATTR(1),
-	DECLARE_FAN_SPEED_RPM_ATTR(2),
-	DECLARE_FAN_SPEED_RPM_ATTR(3),
-	DECLARE_FAN_SPEED_RPM_ATTR(4),
-	DECLARE_FAN_SPEED_RPM_ATTR(5),
-	DECLARE_FAN_PRESENT_ATTR(1),
-	DECLARE_FAN_PRESENT_ATTR(2),
-	DECLARE_FAN_PRESENT_ATTR(3),
-	DECLARE_FAN_PRESENT_ATTR(4),
-	DECLARE_FAN_PRESENT_ATTR(5),	
-	NULL
+    &sensor_dev_attr_cpld_version.dev_attr.attr,
+    &sensor_dev_attr_raw_access.dev_attr.attr,
+    &sensor_dev_attr_fan_watchdog.dev_attr.attr,  
+    DECLARE_FAN_ENABLE_ATTR(1),
+    DECLARE_FAN_ENABLE_ATTR(2),
+    DECLARE_FAN_ENABLE_ATTR(3),
+    DECLARE_FAN_ENABLE_ATTR(4),
+    DECLARE_FAN_ENABLE_ATTR(5), 
+    DECLARE_FAN_DUTY_CYCLE_ATTR(1), 
+    /* fan related attributes */
+    DECLARE_FAN_FAULT_ATTR(1),
+    DECLARE_FAN_FAULT_ATTR(2),
+    DECLARE_FAN_FAULT_ATTR(3),
+    DECLARE_FAN_FAULT_ATTR(4),
+    DECLARE_FAN_FAULT_ATTR(5),
+    DECLARE_FAN_DIRECTION_ATTR(1),
+    DECLARE_FAN_DIRECTION_ATTR(2),
+    DECLARE_FAN_DIRECTION_ATTR(3),
+    DECLARE_FAN_DIRECTION_ATTR(4),
+    DECLARE_FAN_DIRECTION_ATTR(5),
+    DECLARE_FAN_SPEED_RPM_ATTR(1),
+    DECLARE_FAN_SPEED_RPM_ATTR(2),
+    DECLARE_FAN_SPEED_RPM_ATTR(3),
+    DECLARE_FAN_SPEED_RPM_ATTR(4),
+    DECLARE_FAN_SPEED_RPM_ATTR(5),
+    DECLARE_FAN_PRESENT_ATTR(1),
+    DECLARE_FAN_PRESENT_ATTR(2),
+    DECLARE_FAN_PRESENT_ATTR(3),
+    DECLARE_FAN_PRESENT_ATTR(4),
+    DECLARE_FAN_PRESENT_ATTR(5),    
+    NULL
 };
 
-#define FAN_DUTY_CYCLE_REG_MASK			0x0F
-#define FAN_MAX_DUTY_CYCLE			255
-#define FAN_REG_VAL_TO_SPEED_RPM_STEP   	100
-#define FAN_MAX_WATCHDOG_SECONDS		255
-#define I2C_RW_RETRY_COUNT			10
-#define I2C_RW_RETRY_INTERVAL			60 /* ms */
+#define FAN_DUTY_CYCLE_REG_MASK         0x0F
+#define FAN_MAX_DUTY_CYCLE              100
+#define FAN_REG_VAL_TO_SPEED_RPM_STEP       100
+#define FAN_MAX_WATCHDOG_SECONDS        255
+#define I2C_RW_RETRY_COUNT          10
+#define I2C_RW_RETRY_INTERVAL           60 /* ms */
 
 static int t600_fan_read_value(struct i2c_client *client, u8 reg)
 {
-	int status = 0, retry = I2C_RW_RETRY_COUNT;
+    int status = 0, retry = I2C_RW_RETRY_COUNT;
 
-	while (retry) {
-		status = i2c_smbus_read_byte_data(client, reg);
-		if (unlikely(status < 0)) {
-			msleep(I2C_RW_RETRY_INTERVAL);
-			retry--;
-			continue;
-		}
+    while (retry) {
+        status = i2c_smbus_read_byte_data(client, reg);
+        if (unlikely(status < 0)) {
+            msleep(I2C_RW_RETRY_INTERVAL);
+            retry--;
+            continue;
+        }
 
-		break;
-	}
+        break;
+    }
 
     return status;
 }
 static int t600_fan_write_value(struct i2c_client *client, u8 reg, u8 value)
 {
-	int status = 0, retry = I2C_RW_RETRY_COUNT;
+    int status = 0, retry = I2C_RW_RETRY_COUNT;
 
-	while (retry) {
-		status = i2c_smbus_write_byte_data(client, reg, value);
-		if (unlikely(status < 0)) {
-			msleep(I2C_RW_RETRY_INTERVAL);
-			retry--;
-			continue;
-		}
+    while (retry) {
+        status = i2c_smbus_write_byte_data(client, reg, value);
+        if (unlikely(status < 0)) {
+            msleep(I2C_RW_RETRY_INTERVAL);
+            retry--;
+            continue;
+        }
 
-		break;
-	}
+        break;
+    }
 
     return status;
 }
@@ -269,334 +272,356 @@ static int t600_fan_write_value(struct i2c_client *client, u8 reg, u8 value)
 /* fan utility functions */
 static u32 reg_val_to_duty_cycle(u8 reg_val) 
 {
-	reg_val &= FAN_DUTY_CYCLE_REG_MASK;
-	return ((u32) reg_val * 39)/100;
+    reg_val &= FAN_DUTY_CYCLE_REG_MASK;
+    return ((u32) reg_val * 625)/100;
 }
 static u8 duty_cycle_to_reg_val(u8 duty_cycle) 
 {
 
-	return ((u32) duty_cycle * 100) / 39;
+    return ((u32) duty_cycle * 100) / 625;
 }
 static u32 reg_val_to_speed_rpm(u8 reg_val)
 {
-	return (u32)reg_val * FAN_REG_VAL_TO_SPEED_RPM_STEP;
+    return (u32)reg_val * FAN_REG_VAL_TO_SPEED_RPM_STEP;
 }
 static u8 reg_val_to_direction(u8 reg_val, enum fan_id id)
 {
-	u8 mask = (1 << id);
+    u8 mask = (1 << id);
 
-	reg_val &= mask;
+    reg_val &= mask;
 
-	return reg_val ? 1 : 0;
+    return reg_val ? 1 : 0;
 }
 static u8 reg_val_to_is_present(u8 reg_val, enum fan_id id)
 {
-	u8 mask = (1 << id);
+    u8 mask = (1 << id);
 
-	reg_val &= mask;
+    reg_val &= mask;
 
-	return reg_val ? 0 : 1;
+    return reg_val ? 0 : 1;
 }
 static u8 reg_val_to_is_enable(u8 reg_val, enum fan_id id)
 {
-	u8 mask = (1 << id);
+    u8 mask = (1 << id);
 
-	reg_val &= mask;
+    reg_val &= mask;
 
-	return reg_val ? 1 : 0;
+    return reg_val ? 1 : 0;
 }
 static u8 is_fan_failed(struct t600_fan_data *data, enum fan_id id)
 {
-	u8 ret = 1;
-	int front_fan_index = FAN_1_INPUT_ATTR_ID(1) + id;
-	int rear_fan_index  = FAN_2_INPUT_ATTR_ID(1)  + id;
-
-	/* Check if the speed of front or rear fan is ZERO,  
-	 */
-	if (reg_val_to_speed_rpm(data->reg_val[front_fan_index]) &&
-		reg_val_to_speed_rpm(data->reg_val[rear_fan_index]))  {
-		ret = 0;
-	}
-	return ret;
+    u8 ret = 1;
+    int front_fan_index = FAN_1_INPUT_ATTR_ID(1) + id;
+    int rear_fan_index  = FAN_2_INPUT_ATTR_ID(1)  + id;
+
+    /* Check if the speed of front or rear fan is ZERO,  
+     */
+    if (reg_val_to_speed_rpm(data->reg_val[front_fan_index]) &&
+        reg_val_to_speed_rpm(data->reg_val[rear_fan_index]))  {
+        ret = 0;
+    }
+    return ret;
 }
 static int fan_set_duty_cycle_to_cpld(struct i2c_client *client, int new_duty_cycle)
 {
-	struct t600_fan_data *data = i2c_get_clientdata(client);
-	u8 reg = fan_reg[0x3];
-	int ret;
-	
-	if (new_duty_cycle < 0 || new_duty_cycle > 255) {
-		new_duty_cycle = 255;
-	}
-#if 0 //No watchdog 	
-	/* Disable the watchdog timer
-	 */
-	ret = t600_fan_write_value(client, 0x33, 0);
-	
-	if (ret != 0) {
-		dev_dbg(&client->dev, "Unable to disable the watchdog timer\n");
-		return ret;
-	}
-#endif	
-	/* Update duty cycle
-	 */
-	mutex_lock(&data->update_lock);
-	data->reg_val[FAN_PWM1] = new_duty_cycle;
-	ret = t600_fan_write_value(client, reg, new_duty_cycle);
-	mutex_unlock(&data->update_lock);
-	
-	return ret;
+    struct t600_fan_data *data = i2c_get_clientdata(client);
+    u8 reg = fan_reg[0x3];
+    int ret;
+    
+    if (new_duty_cycle < 1 || new_duty_cycle > 16) {
+        new_duty_cycle = 16;   /* New CPLD value range: 1 ~ 16*/
+    }
+
+    /* Update duty cycle
+     */
+    mutex_lock(&data->update_lock);
+    data->reg_val[FAN_PWM1] = new_duty_cycle;
+    ret = t600_fan_write_value(client, reg, new_duty_cycle);
+    mutex_unlock(&data->update_lock);
+    
+    return ret;
 }
 static ssize_t set_duty_cycle(struct device *dev, struct device_attribute *da,
-			const char *buf, size_t count) 
+            const char *buf, size_t count) 
 {
-	int error, value;
-	struct i2c_client *client = to_i2c_client(dev);
-	
-	error = kstrtoint(buf, 10, &value);
-	if (error) {
-		return error;
-	}
-		
-	if (value < 0 || value > FAN_MAX_DUTY_CYCLE) {
-		return -EINVAL;
-	}
-	
-	fan_set_duty_cycle_to_cpld(client, duty_cycle_to_reg_val(value));
-	
-	return count;
+    int error, value;
+    struct i2c_client *client = to_i2c_client(dev);
+    
+    error = kstrtoint(buf, 10, &value);
+    if (error) {
+        return error;
+    }
+        
+    if (value < 0 || value > FAN_MAX_DUTY_CYCLE) {
+        return -EINVAL;
+    }
+    
+    fan_set_duty_cycle_to_cpld(client, duty_cycle_to_reg_val(value));
+    
+    return count;
 }
 static int fan_set_enable_to_cpld(struct i2c_client *client, u8 reg, int index, int new_value)
 {
-	struct t600_fan_data *data = i2c_get_clientdata(client);
-	int ret;
-				
-	mutex_lock(&data->update_lock);
-        data->reg_val[index] = new_value;
-	ret = t600_fan_write_value(client, reg, new_value);
-	mutex_unlock(&data->update_lock);
-	
-	return ret;
+    struct t600_fan_data *data = i2c_get_clientdata(client);
+    int ret;
+                
+    mutex_lock(&data->update_lock);
+    data->reg_val[index] = new_value;
+    ret = t600_fan_write_value(client, reg, new_value);
+    mutex_unlock(&data->update_lock);
+    
+    return ret;
 }
 static ssize_t set_fan_enable(struct device *dev, struct device_attribute *da, const char *buf, size_t count) 
 {
-	int error, value, index;
-	u8 reg = 0, mask = 0;
-	int regval;
+    int error, value, index;
+    u8 reg = 0, mask = 0;
+    int regval;
         struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
-	struct i2c_client *client = to_i2c_client(dev);
-	struct t600_fan_data *data = i2c_get_clientdata(client);
-
-	error = kstrtoint(buf, 10, &value);
-	if (error) {
-		return error;
-	}
-		
-	if (value < 0 || value > 1) {
-		return -EINVAL;
-	}
-	reg  = fan_reg[FAN_ENABLE_REG];
-	regval = data->reg_val[FAN_ENABLE_REG];
-	mask = 0x1 << (attr->index - FAN1_ENABLE);
-	regval = value ? (regval | mask) : (regval & ~mask);	
-	index = FAN_ENABLE_REG;
-	fan_set_enable_to_cpld(client, reg, index, regval);
-
-	return count;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_fan_data *data = i2c_get_clientdata(client);
+
+    error = kstrtoint(buf, 10, &value);
+    if (error) {
+        return error;
+    }
+        
+    if (value < 0 || value > 1) {
+        return -EINVAL;
+    }
+    reg  = fan_reg[FAN_ENABLE_REG];
+    regval = data->reg_val[FAN_ENABLE_REG];
+    mask = 0x1 << (attr->index - FAN1_ENABLE);
+    regval = value ? (regval | mask) : (regval & ~mask);    
+    index = FAN_ENABLE_REG;
+    fan_set_enable_to_cpld(client, reg, index, regval);
+
+    return count;
+}
+
+static ssize_t set_fan_watchdog(struct device *dev, struct device_attribute *da, const char *buf, size_t count) 
+{
+    int error, value, index;
+    u8 reg = 0, mask = 0x1;
+    int regval;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_fan_data *data = i2c_get_clientdata(client);
+
+    error = kstrtoint(buf, 10, &value);
+    if (error) {
+        return error;
+    }
+        
+    if (value < 0 || value > 1) {
+        return -EINVAL;
+    }
+    reg  = fan_reg[FAN_WATCHDOG];
+    regval = data->reg_val[FAN_WATCHDOG];
+    regval = value ? (regval | mask) : (regval & ~mask);    
+    index = FAN_WATCHDOG;
+    fan_set_enable_to_cpld(client, reg, index, regval);
+
+    return count;
 }
 
 static ssize_t raw_access(struct device *dev, struct device_attribute *da,
-			const char *buf, size_t count)
+            const char *buf, size_t count)
 {
-	u32 addr, val;
-	
+    u32 addr, val;
+    
         int status;
         struct i2c_client *client = to_i2c_client(dev);
         struct t600_fan_data *data = i2c_get_clientdata(client);
 
-	if (sscanf(buf, "0x%x 0x%x", &addr, &val) != 2) {
-		return -EINVAL;
-	}
-
-	if (addr > 0xFF || val > 0xFF) {
-		return -EINVAL;
-	}
-
-	mutex_lock(&data->update_lock);
-	status = t600_fan_write_value(client, addr, val);
-	if (unlikely(status < 0)) {
-		goto exit;
-	}
-	mutex_unlock(&data->update_lock);
-	return count;
+    if (sscanf(buf, "0x%x 0x%x", &addr, &val) != 2) {
+        return -EINVAL;
+    }
+
+    if (addr > 0xFF || val > 0xFF) {
+        return -EINVAL;
+    }
+
+    mutex_lock(&data->update_lock);
+    status = t600_fan_write_value(client, addr, val);
+    if (unlikely(status < 0)) {
+        goto exit;
+    }
+    mutex_unlock(&data->update_lock);
+    return count;
 exit:
-	mutex_unlock(&data->update_lock);
-	return status;	
+    mutex_unlock(&data->update_lock);
+    return status;  
 
 
 }
 static ssize_t fan_show_value(struct device *dev, struct device_attribute *da,
-			 char *buf)
+             char *buf)
 {
-	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
-	struct t600_fan_data *data = t600_fan_update_device(dev);
-	ssize_t ret = 0;
-	
-	if (data->valid) {
-		switch (attr->index) {
-			case FAN_PWM1:
-			{
-				u32 duty_cycle = reg_val_to_duty_cycle(data->reg_val[FAN_PWM1]);
-				ret = sprintf(buf, "%u\n", duty_cycle);
-				break;
-			}
-			case FAN_1_INPUT_ATTR_ID(1)...FAN_2_INPUT_ATTR_ID(5):			
-				ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[attr->index]));
-				break;
-			case FAN_DIRECTION_ATTR_ID(1)...FAN_DIRECTION_ATTR_ID(5):
-				ret = sprintf(buf, "%d\n", 
-							  reg_val_to_direction(data->reg_val[FAN_DIRECTION_REG],
-							  attr->index - FAN_DIRECTION_ATTR_ID(1) ));
-                        							  
-				break;
-			case FAN_PRESENT_ATTR_ID(1)...FAN_PRESENT_ATTR_ID(5):
-				ret = sprintf(buf, "%d\n",
-							  reg_val_to_is_present(data->reg_val[FAN_PRESENT_REG],
-							  attr->index - FAN_PRESENT_ATTR_ID(1) ));				  
-				break;
-			case FAN_FAULT_ATTR_ID(1)...FAN_FAULT_ATTR_ID(5):
-				ret = sprintf(buf, "%d\n", is_fan_failed(data, attr->index - FAN_FAULT_ATTR_ID(1) ));
-				break;
-			case CPLD_VERSION:
-				ret = sprintf(buf, "%d\n", data->reg_val[CPLD_VERSION]);
-				break;
-
-			case FAN_ENABLE_ATTR_ID(1)...FAN_ENABLE_ATTR_ID(5):
-				ret = sprintf(buf, "%d\n",
-							  reg_val_to_is_enable(data->reg_val[FAN_ENABLE_REG],
-							  attr->index - FAN_ENABLE_ATTR_ID(1) ));
-				break; 						
-			default:
-				break;
-		}		
-	}
-	
-	return ret;
+    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+    struct t600_fan_data *data = t600_fan_update_device(dev);
+    ssize_t ret = 0;
+    
+    if (data->valid) {
+        switch (attr->index) {
+            case FAN_PWM1:
+            {
+                u32 duty_cycle = reg_val_to_duty_cycle(data->reg_val[FAN_PWM1]);
+                ret = sprintf(buf, "%u\n", duty_cycle);
+                break;
+            }
+            case FAN_1_INPUT_ATTR_ID(1)...FAN_2_INPUT_ATTR_ID(5):           
+                ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[attr->index]));
+                break;
+            case FAN_DIRECTION_ATTR_ID(1)...FAN_DIRECTION_ATTR_ID(5):
+                ret = sprintf(buf, "%d\n", 
+                              reg_val_to_direction(data->reg_val[FAN_DIRECTION_REG],
+                              attr->index - FAN_DIRECTION_ATTR_ID(1) ));
+                                                      
+                break;
+            case FAN_PRESENT_ATTR_ID(1)...FAN_PRESENT_ATTR_ID(5):
+                ret = sprintf(buf, "%d\n",
+                              reg_val_to_is_present(data->reg_val[FAN_PRESENT_REG],
+                              attr->index - FAN_PRESENT_ATTR_ID(1) ));                
+                break;
+            case FAN_FAULT_ATTR_ID(1)...FAN_FAULT_ATTR_ID(5):
+                ret = sprintf(buf, "%d\n", is_fan_failed(data, attr->index - FAN_FAULT_ATTR_ID(1) ));
+                break;
+            case CPLD_VERSION:
+                ret = sprintf(buf, "%d\n", data->reg_val[CPLD_VERSION]);
+                break;
+
+            case FAN_ENABLE_ATTR_ID(1)...FAN_ENABLE_ATTR_ID(5):
+                ret = sprintf(buf, "%d\n",
+                              reg_val_to_is_enable(data->reg_val[FAN_ENABLE_REG],
+                              attr->index - FAN_ENABLE_ATTR_ID(1) ));
+                break;
+
+            case FAN_WATCHDOG:
+                ret = sprintf(buf, "%d\n",
+                              reg_val_to_is_enable(data->reg_val[FAN_WATCHDOG], 0) );
+                break;
+                
+            default:
+                break;
+        }       
+    }
+    
+    return ret;
 }
 
 static const struct attribute_group t600_fan_group = {
-	.attrs = t600_fan_attributes,
+    .attrs = t600_fan_attributes,
 };
 
 static struct t600_fan_data *t600_fan_update_device(struct device *dev)
 {
-	struct i2c_client *client = to_i2c_client(dev);
-	struct t600_fan_data *data = i2c_get_clientdata(client);
-
-	mutex_lock(&data->update_lock);
-
-	if (time_after(jiffies, data->last_updated + HZ + HZ / 2) || 
-		!data->valid) {
-		int i;
-
-		dev_dbg(&client->dev, "Starting t600_fan update\n");
-		data->valid = 0;
-		
-		/* Update fan data
-		 */
-		for (i = 0; i < ARRAY_SIZE(data->reg_val); i++) {
-			int status = t600_fan_read_value(client, fan_reg[i]);
-			
-			if (status < 0) {
-				printk(KERN_INFO "reg %d, err %d\r\n", fan_reg[i], status);
-				dev_dbg(&client->dev, "reg %d, err %d\n", fan_reg[i], status);
-				goto exit;
-			}
-			else {
-				data->reg_val[i] = status;
-			}
-		}
-		data->last_updated = jiffies;
-		data->valid = 1;
-	}
-
-exit:	
-	mutex_unlock(&data->update_lock);
-
-	return data;
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_fan_data *data = i2c_get_clientdata(client);
+
+    mutex_lock(&data->update_lock);
+
+    if (time_after(jiffies, data->last_updated + HZ + HZ / 2) || 
+        !data->valid) {
+        int i;
+
+        dev_dbg(&client->dev, "Starting t600_fan update\n");
+        data->valid = 0;
+        
+        /* Update fan data
+         */
+        for (i = 0; i < ARRAY_SIZE(data->reg_val); i++) {
+            int status = t600_fan_read_value(client, fan_reg[i]);
+            
+            if (status < 0) {
+                printk(KERN_INFO "reg %d, err %d\r\n", fan_reg[i], status);
+                dev_dbg(&client->dev, "reg %d, err %d\n", fan_reg[i], status);
+                goto exit;
+            }
+            else {
+                data->reg_val[i] = status;
+            }
+        }
+        data->last_updated = jiffies;
+        data->valid = 1;
+    }
+
+exit:   
+    mutex_unlock(&data->update_lock);
+
+    return data;
 }
 
 static int t600_fan_probe(struct i2c_client *client,
-			const struct i2c_device_id *dev_id)
+            const struct i2c_device_id *dev_id)
 {
-	struct t600_fan_data *data;
-	int status;
-
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
-		status = -EIO;
-		goto exit;
-	}
-	data = kzalloc(sizeof(struct t600_fan_data), GFP_KERNEL);
-	if (!data) {
-		status = -ENOMEM;
-		goto exit;
-	}
-	i2c_set_clientdata(client, data);
-	data->valid = 0;
-	mutex_init(&data->update_lock);
-
-	dev_info(&client->dev, "chip found\n");
-
-	/* Register sysfs hooks */
-	status = sysfs_create_group(&client->dev.kobj, &t600_fan_group);
-	if (status) {
-		goto exit_free;
-	}
-	data->hwmon_dev = hwmon_device_register(&client->dev);
-	if (IS_ERR(data->hwmon_dev)) {
-		status = PTR_ERR(data->hwmon_dev);
-		goto exit_remove;
-	}
-
-	dev_info(&client->dev, "%s: fan '%s'\n",
-		 dev_name(data->hwmon_dev), client->name);
-
-	return 0;
+    struct t600_fan_data *data;
+    int status;
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+        status = -EIO;
+        goto exit;
+    }
+    data = kzalloc(sizeof(struct t600_fan_data), GFP_KERNEL);
+    if (!data) {
+        status = -ENOMEM;
+        goto exit;
+    }
+    i2c_set_clientdata(client, data);
+    data->valid = 0;
+    mutex_init(&data->update_lock);
+
+    dev_info(&client->dev, "chip found\n");
+
+    /* Register sysfs hooks */
+    status = sysfs_create_group(&client->dev.kobj, &t600_fan_group);
+    if (status) {
+        goto exit_free;
+    }
+    data->hwmon_dev = hwmon_device_register(&client->dev);
+    if (IS_ERR(data->hwmon_dev)) {
+        status = PTR_ERR(data->hwmon_dev);
+        goto exit_remove;
+    }
+
+    dev_info(&client->dev, "%s: fan '%s'\n",
+         dev_name(data->hwmon_dev), client->name);
+
+    return 0;
 
 exit_remove:
-	sysfs_remove_group(&client->dev.kobj, &t600_fan_group);
+    sysfs_remove_group(&client->dev.kobj, &t600_fan_group);
 exit_free:
-	kfree(data);
+    kfree(data);
 exit:
-	
-	return status;
+    
+    return status;
 }
 static int t600_fan_remove(struct i2c_client *client)
 {
-	struct t600_fan_data *data = i2c_get_clientdata(client);
-	
-	hwmon_device_unregister(data->hwmon_dev);
-	sysfs_remove_group(&client->dev.kobj, &t600_fan_group);
-	kfree(data);
-	
-	return 0;
+    struct t600_fan_data *data = i2c_get_clientdata(client);
+    
+    hwmon_device_unregister(data->hwmon_dev);
+    sysfs_remove_group(&client->dev.kobj, &t600_fan_group);
+    kfree(data);
+    
+    return 0;
 }
 /* Addresses to scan */
 static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
 static const struct i2c_device_id t600_fan_id[] = {
-	{ DRVNAME, 0 },
-	{}
+    { DRVNAME, 0 },
+    {}
 };
 MODULE_DEVICE_TABLE(i2c, t600_fan_id);
 static struct i2c_driver t600_fan_driver = {
-	.class		= I2C_CLASS_HWMON,
-	.driver = {
-		.name	 = DRVNAME,
-	},
-	.probe		= t600_fan_probe,
-	.remove	   = t600_fan_remove,
-	.id_table	 = t600_fan_id,
-	.address_list = normal_i2c,
+    .class      = I2C_CLASS_HWMON,
+    .driver = {
+        .name    = DRVNAME,
+    },
+    .probe      = t600_fan_probe,
+    .remove    = t600_fan_remove,
+    .id_table    = t600_fan_id,
+    .address_list = normal_i2c,
 };
 module_i2c_driver(t600_fan_driver);
 MODULE_AUTHOR("Vic Lin <vic_lin@accton.com.tw>");
diff --git a/drivers/misc/accton_t600_fj_mdec.c b/drivers/misc/accton_t600_fj_mdec.c
index 659a424..35f5415 100644
--- a/drivers/misc/accton_t600_fj_mdec.c
+++ b/drivers/misc/accton_t600_fj_mdec.c
@@ -63,7 +63,7 @@
 // MDEC
 #define MDEC_WRITE_MODE                                         (0x0001)
 #define MDEC_READ_MODE                                          (0x0000)
-#define MDEC_EEPROM_SIZE                                        256 
+#define MDEC_EEPROM_SIZE                                        512
 #define MDEC_EEPROM_ADDR                                        0x00F00000
 
 // I2C
@@ -195,28 +195,25 @@ static ssize_t read_mdec_eeprom(struct device* dev, struct device_attribute* att
 {
     u32 value;
     char __iomem* mem_addr;
-    char temp[8];
-    char buf1[MDEC_EEPROM_SIZE * 2];
-
+    u8 eerpom_buf[MDEC_EEPROM_SIZE];
     int i = 0;
     struct fpga_device* fpga_dev = dev_get_drvdata(dev);
-    mem_addr = fpga_dev->hw_addr;
 
-    memset(buf1, 0, MDEC_EEPROM_SIZE * 2);
-    memset(temp, 0, 8);
     mutex_lock(&fpga_dev->driver_lock);    
     mem_addr = fpga_dev->hw_addr + MDEC_EEPROM_ADDR;
-    
-    for(i = 0; i < (MDEC_EEPROM_SIZE / 4); i++)
+
+    for(i = 0; i < MDEC_EEPROM_SIZE; i+=4)
     {
-        value = t600_fj_mdec_read32(mem_addr);
-        sprintf(temp, "%08X", value);
-        mem_addr = mem_addr + 0x00000004;
-        strcat(buf1, temp);
+        value = t600_fj_mdec_read32(mem_addr + i);
+        eerpom_buf[i + 0] = value >> 24;
+        eerpom_buf[i + 1] = value >> 16;
+        eerpom_buf[i + 2] = value >> 8;
+        eerpom_buf[i + 3] = value >> 0;
     }
 
     mutex_unlock(&fpga_dev->driver_lock);
-    return sprintf(buf, "%s\n", buf1);
+    memcpy(buf, eerpom_buf, MDEC_EEPROM_SIZE);
+    return MDEC_EEPROM_SIZE;
 }
 
 static ssize_t qsfp_read_result(struct device* dev, struct device_attribute* attr, char* buf)
@@ -236,12 +233,10 @@ static ssize_t mdio_action_store(struct device* dev, struct device_attribute* at
     {
         return  - EINVAL;
     } 
-    
-    printk(KERN_INFO "[DEBUG] mode=%04X, page=%04X, address=%04X, data=%04X\r\n", (u16)mode, (u16)page, (u16)address, (u16)data);
-    
+
     if(mode > MDIO_WRITE_MODE)
     {
-        printk(KERN_INFO "[ERR] mode ERR, mode range is 0X0000 ~0x0001 \r\n");
+        printk(KERN_WARNING "[ERR] mode ERR, mode range is 0X0000 ~0x0001 \r\n");
         return  - EINVAL;
     }
     
@@ -323,7 +318,6 @@ MDIO_READ_BEGIN:
               
             if(status == MDIO_BUS_CHK_OK)
             {
-                printk(KERN_INFO "[DEBUG] MDIO BUS bus is OK\r\n");
                   // NOT BUSY
                   break;
             }
@@ -331,7 +325,7 @@ MDIO_READ_BEGIN:
             {
                 goto MDIO_READ_BEGIN;   
             }
-            printk(KERN_INFO "[DEBUG] I2C bus busy, retry count =%d\r\n", i);
+            printk(KERN_DEBUG "[DEBUG] I2C bus busy, 1retry count =%d\r\n", i);
         }   
         // Read data
         mdio_read_result_data = t600_fj_mdec_read32(fpga_dev->hw_addr + BMD_BUS_MDIO_RD_DT);
@@ -352,12 +346,10 @@ static ssize_t mdec_action_store(struct device* dev, struct device_attribute* at
     {
         return  - EINVAL;
     } 
-    
-    printk(KERN_INFO "[DEBUG] mode=%08X, address=%08X, data=%08X\r\n", mode, address, data);
-    
+
     if(mode > MDIO_WRITE_MODE)
     {
-        printk(KERN_INFO "[ERR] mode ERR, mode range is 0X00000000 ~0x00000001 \r\n");
+        printk(KERN_WARNING "[ERR] mode ERR, mode range is 0X00000000 ~0x00000001 \r\n");
         return  - EINVAL;
     }
     
@@ -389,12 +381,10 @@ static ssize_t qsfp_action_store(struct device* dev, struct device_attribute* at
     {
         return  - EINVAL;
     } 
-    
-    printk(KERN_INFO "[DEBUG] mode=%02X, address=%02X, data=%02X\r\n", mode, address, data);
-    
+
     if(mode > I2C_WRITE_MODE)
     {
-        printk(KERN_INFO "[ERR] mode ERR, mode range is 0X00000000 ~0x00000001 \r\n");
+        printk(KERN_WARNING "[ERR] mode ERR, mode range is 0X00000000 ~0x00000001 \r\n");
         return  - EINVAL;
     }
     
@@ -408,7 +398,7 @@ static ssize_t qsfp_action_store(struct device* dev, struct device_attribute* at
     else
     {
         qsfp_read_result_data = read_port_eeprom_one_byte(fpga_dev, port, address);
-        printk(KERN_INFO "[DEBUG] READ - I2C_READ_DT = %02x\n", qsfp_read_result_data);
+        printk(KERN_DEBUG "[DEBUG] READ - I2C_READ_DT = %02x\n", qsfp_read_result_data);
     }
 
 
@@ -642,18 +632,17 @@ static void write_port_eeprom_one_byte(struct fpga_device* fpga_dev, u8 port, u8
         status = t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_BUSY + (port << 16)); //0x00An0130, n means port
         if(status == 0)
         {
-            printk(KERN_INFO "[DEBUG] I2C bus is idle \r\n"); // idle
               break;
         }
+
         udelay(200);
-        
         if(i == (I2C_CHK_BUS_BUSY_RETRY_COUNT -1))
         {
             printk(KERN_ERR "I2C bus is busy, retry 200 timeout \r\n");
         }
         else
         {
-            printk(KERN_INFO "[DEBUG] I2C bus is busy, retry count =%d\r\n", i + 1);            
+            printk(KERN_DEBUG "[DEBUG] I2C bus is busy, retry count =%d\r\n", i + 1);
         }
     }
 
@@ -667,19 +656,19 @@ static void write_port_eeprom_one_byte(struct fpga_device* fpga_dev, u8 port, u8
         // Write Trigger
         t600_fj_mdec_write32(I2C_ACC_CMD_WRITE, fpga_dev->hw_addr + I2C_ACC_CMD + (port << 16)); //0x00An0134, n means port
         status = t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_IRQ_ERR_HL + (port << 12));
-        printk(KERN_INFO "[DEBUG] check - I2C_IRQ_ERR_HL status = %08x(Err), count = %d\n", status, i+1);
         if(status == 0)
         {
-            printk(KERN_INFO "[DEBUG] check - I2C_IRQ_ERR_HL status = NO Err\n");
+            // NO Error
             break;  
         }
+
         if(i == (I2C_READ_STATUS_RETRY_COUNT -1))
         {
             printk(KERN_ERR "check - I2C_IRQ_ERR_HL status is err, retry 3 timeout \r\n");
         }
         else
         {
-            printk(KERN_INFO "[DEBUG] check - I2C_IRQ_ERR_HL status is err, retry count =%d\r\n", i+1);         
+            printk(KERN_DEBUG "[DEBUG] check - I2C_IRQ_ERR_HL status is err, retry count =%d\r\n", i+1);
         }
     }
 
@@ -716,12 +705,11 @@ static u8 read_port_eeprom_one_byte(struct fpga_device* fpga_dev, u8 port, u8 po
         status = t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_BUSY + (port << 16)); //0x00An0130, n means port
         if(status == 0)
         {
-            printk(KERN_INFO "[DEBUG] I2C bus NOT busy \r\n");
-              // NOT BUSY
+            // NOT BUSY
             break;
         }
         udelay(200);
-        printk(KERN_INFO "[DEBUG] I2C bus busy, retry count =%d\r\n", i + 1);
+        printk(KERN_DEBUG "[DEBUG] I2C bus busy, 2retry count =%d\r\n", i + 1);
     }
         
     for(i = 0; i < I2C_READ_STATUS_RETRY_COUNT ; i++)
@@ -738,20 +726,19 @@ static u8 read_port_eeprom_one_byte(struct fpga_device* fpga_dev, u8 port, u8 po
             status = t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_BUSY + (port << 16)); //0x00An0130, n means port
             if(status == 0)
             {
-                printk(KERN_INFO "[DEBUG] I2C bus NOT busy \r\n");
-                  // NOT BUSY
+                // NOT BUSY
                 break;
             }
-            printk(KERN_INFO "[DEBUG] I2C bus busy, retry count =%d\r\n", j);
+            printk(KERN_DEBUG "[DEBUG] I2C bus busy, 3retry count =%d\r\n", j);
         }
 
         status = t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_IRQ_ERR_HL + (port << 16)); //0x00An0120, n means port
-        printk(KERN_INFO "[DEBUG] check - I2C_IRQ_ERR_HL status = %08x(Err), count = %d\n", status, i+1);
         if(status == 0)
         {
-            printk(KERN_INFO "[DEBUG] check - I2C_IRQ_ERR_HL status = NO Err\n");
             break;  
         }
+
+        printk(KERN_DEBUG "[DEBUG] check - I2C_IRQ_ERR_HL status = %08x(Err), count = %d\n", status, i+1);
     }
     
     value = (u8)t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_READ_DT + (port << 16)); //0x00An0144, n means port
-- 
1.9.1

