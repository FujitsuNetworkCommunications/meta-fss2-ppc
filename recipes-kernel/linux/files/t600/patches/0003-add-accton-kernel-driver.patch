From 728f804ab22ec43e05faadce304a6c43f55ec14d Mon Sep 17 00:00:00 2001
From: aken_liu <aken_liu@accton.com.tw>
Date: Thu, 19 Jul 2018 21:26:05 +0800
Subject: [PATCH] add accton kernel driver

---
 drivers/hwmon/Kconfig              |   16 +
 drivers/hwmon/Makefile             |    2 +
 drivers/hwmon/accton_t600_cpld.c   |  679 ++++++++++++++++++++++++
 drivers/hwmon/accton_t600_fan.c    |  605 +++++++++++++++++++++
 drivers/misc/Kconfig               |    9 +
 drivers/misc/Makefile              |    1 +
 drivers/misc/accton_t600_fj_mdec.c | 1009 ++++++++++++++++++++++++++++++++++++
 7 files changed, 2321 insertions(+)
 create mode 100644 drivers/hwmon/accton_t600_cpld.c
 create mode 100644 drivers/hwmon/accton_t600_fan.c
 create mode 100644 drivers/misc/accton_t600_fj_mdec.c

diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 4201c7e..41002b5 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -81,6 +81,22 @@ config SENSORS_ABITUGURU3
 	  This driver can also be built as a module.  If so, the module
 	  will be called abituguru3.
 
+config SENSORS_ACCTON_T600_CPLD
+	tristate "Accton T600 cpld"
+	depends on I2C
+	help
+	  If you say yes here you get support for Accton t600 cpld.
+	  This driver can also be built as a module. If so, the module will
+	  be called accton_t600_cpld.
+
+config SENSORS_ACCTON_T600_FAN
+	tristate "Accton T600 fan"
+	depends on I2C
+	help
+	  If you say yes here you get support for Accton T600 fan.
+	  This driver can also be built as a module. If so, the module will
+	  be called accton_t600_fan.
+
 config SENSORS_AD7314
 	tristate "Analog Devices AD7314 and compatibles"
 	depends on SPI
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index eacd2ee..e3cdd72 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -22,6 +22,8 @@ obj-$(CONFIG_SENSORS_W83791D)	+= w83791d.o
 obj-$(CONFIG_SENSORS_AB8500)	+= abx500.o ab8500.o
 obj-$(CONFIG_SENSORS_ABITUGURU)	+= abituguru.o
 obj-$(CONFIG_SENSORS_ABITUGURU3)+= abituguru3.o
+obj-$(CONFIG_SENSORS_ACCTON_T600_CPLD) += accton_t600_cpld.o
+obj-$(CONFIG_SENSORS_ACCTON_T600_FAN)  += accton_t600_fan.o
 obj-$(CONFIG_SENSORS_AD7314)	+= ad7314.o
 obj-$(CONFIG_SENSORS_AD7414)	+= ad7414.o
 obj-$(CONFIG_SENSORS_AD7418)	+= ad7418.o
diff --git a/drivers/hwmon/accton_t600_cpld.c b/drivers/hwmon/accton_t600_cpld.c
new file mode 100644
index 0000000..e29916c
--- /dev/null
+++ b/drivers/hwmon/accton_t600_cpld.c
@@ -0,0 +1,679 @@
+/*
+ * A hwmon driver for the t600_sys_cpld
+ *
+ * Copyright (C) 2013 Accton Technology Corporation.
+ * Brandon Chuang <brandon_chuang@accton.com.tw>
+ *
+ * Based on ad7414.c
+ * Copyright 2006 Stefan Roese <sr at denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/sysfs.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#define DRVNAME "t600_cpld"
+#define I2C_RW_RETRY_COUNT			10
+#define I2C_RW_RETRY_INTERVAL			60 /* ms */
+#define BOARD_REV_REG				0x1
+#define CPLD_VER_REG				0x2
+#define PSU_STATUS_REG				0x3
+#define SFP_PWR_REG				0x14
+#define BOOT_STATUS_REG				0x22
+#define PIU_STATUS_REG				0x24
+#define USB_PG_REG				0x13
+#define BOARD_PG_REG				0x18
+#define PIU_MGMT_PG_REG				0x21
+
+struct t600_cpld_data {
+    struct device      *hwmon_dev;
+    struct mutex        update_lock;
+};
+
+/* Addresses scanned for t600_cpld
+ */
+static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
+
+#define PSU_PRESENT_ATTR_ID(index)		PSU##index##_PRESENT
+#define PSU_OUTPUTGOOD_ATTR_ID(index)  	PSU##index##_OUTPUT_GOOD
+#define PSU_ALARM_ATTR_ID(index)  		PSU##index##_ALARM
+#define PIU_PRESENT_ATTR_ID(index)	PIU##index##_PRESENT
+#define SFP_PWR_ATTR_ID(index)	        SFP##index##_PWR
+
+enum t600_cpld_sysfs_attributes {
+	BOARD_VERSION,
+	CPLD_VERSION,
+	ACCESS,
+    /* reset */
+        RESET,
+  /* bootup status */
+        BOOTUP_STATUS,
+	/* PSU attributes */
+  PSU_PRESENT_ATTR_ID(1),
+  PSU_PRESENT_ATTR_ID(2),
+  PSU_OUTPUTGOOD_ATTR_ID(1),
+  PSU_OUTPUTGOOD_ATTR_ID(2),
+  PSU_ALARM_ATTR_ID(1),
+  PSU_ALARM_ATTR_ID(2),  
+  /* PIU attributes */
+  PIU_PRESENT_ATTR_ID(1),
+  PIU_PRESENT_ATTR_ID(2),  
+  /* SFP attributes */
+  SFP_PWR_ATTR_ID(1),
+  SFP_PWR_ATTR_ID(2),  
+  USB_PWR_FAULT,
+  BOARD_PWR_GOOD,
+  PIU_MGMT_PWR_GOOD,
+     
+};
+static ssize_t show_bootstatus(struct device *dev, struct device_attribute *da,
+             char *buf);
+static ssize_t show_piu(struct device *dev, struct device_attribute *da,
+             char *buf);                
+static ssize_t show_sfp(struct device *dev, struct device_attribute *da,
+             char *buf);                                   
+static ssize_t show_psu(struct device *dev, struct device_attribute *da,
+             char *buf);
+static ssize_t show_reset_status(struct device *dev, struct device_attribute *da,
+             char *buf);
+static ssize_t reset(struct device *dev, struct device_attribute *da,
+			const char *buf, size_t count);
+static ssize_t raw_access(struct device *dev, struct device_attribute *da,
+			const char *buf, size_t count);		
+static ssize_t show_version(struct device *dev, struct device_attribute *da,
+             char *buf);             
+static ssize_t show_pwr_status(struct device *dev, struct device_attribute *da,
+             char *buf);
+static ssize_t set_sfp_power(struct device *dev, struct device_attribute *da,
+                        const char *buf, size_t count);
+
+/* sysfs attributes for hwmon 
+ */
+/* psu attributes */
+#define DECLARE_PSU_SENSOR_DEVICE_ATTR(index) \
+	static SENSOR_DEVICE_ATTR(psu##index##_present,    S_IRUGO, show_psu, NULL, PSU##index##_PRESENT); \
+	static SENSOR_DEVICE_ATTR(psu##index##_power_good, S_IRUGO, show_psu, NULL, PSU##index##_OUTPUT_GOOD); \
+	static SENSOR_DEVICE_ATTR(psu##index##_alarm, S_IRUGO, show_psu, 	 NULL, PSU##index##_ALARM)
+#define DECLARE_PSU_ATTR(index) \
+    &sensor_dev_attr_psu##index##_present.dev_attr.attr, \
+    &sensor_dev_attr_psu##index##_power_good.dev_attr.attr, \
+    &sensor_dev_attr_psu##index##_alarm.dev_attr.attr
+    
+/* sfp attributes */
+#define DECLARE_SFP_SENSOR_DEVICE_ATTR(index) \
+	static SENSOR_DEVICE_ATTR(sfp##index##_pwr, S_IWUSR | S_IRUGO, show_sfp, set_sfp_power, SFP##index##_PWR)
+		
+#define DECLARE_SFP_ATTR(index) \
+    &sensor_dev_attr_sfp##index##_pwr.dev_attr.attr    
+    
+static SENSOR_DEVICE_ATTR(board_version, S_IRUGO, show_version, NULL, BOARD_VERSION);
+static SENSOR_DEVICE_ATTR(cpld_version, S_IRUGO, show_version, NULL, CPLD_VERSION);
+static SENSOR_DEVICE_ATTR(raw_access, S_IWUSR | S_IRUGO, NULL, raw_access, ACCESS);
+
+/* Power Status Good / Fault */
+static SENSOR_DEVICE_ATTR(usb_pwr_fault    , S_IRUGO, show_pwr_status, NULL, USB_PWR_FAULT);
+static SENSOR_DEVICE_ATTR(board_pwr_good   , S_IRUGO, show_pwr_status, NULL, BOARD_PWR_GOOD);
+static SENSOR_DEVICE_ATTR(piu_mgmt_pwr_good, S_IRUGO, show_pwr_status, NULL, PIU_MGMT_PWR_GOOD);
+
+
+/* reset attribtes */
+static SENSOR_DEVICE_ATTR(system_reset, S_IWUSR | S_IRUGO, show_reset_status, reset, RESET);
+/* boot status attribute */
+static SENSOR_DEVICE_ATTR(bootup_status, S_IRUGO, show_bootstatus, NULL, BOOTUP_STATUS);
+/* psu attributes*/
+DECLARE_PSU_SENSOR_DEVICE_ATTR(1);
+DECLARE_PSU_SENSOR_DEVICE_ATTR(2);
+/* piu present attribute */
+static SENSOR_DEVICE_ATTR(piu1_present, S_IRUGO, show_piu, NULL, PIU_PRESENT_ATTR_ID(1));
+static SENSOR_DEVICE_ATTR(piu2_present, S_IRUGO, show_piu, NULL, PIU_PRESENT_ATTR_ID(2));
+/* sfp attributes*/
+DECLARE_SFP_SENSOR_DEVICE_ATTR(1);
+DECLARE_SFP_SENSOR_DEVICE_ATTR(2);
+
+static struct attribute *t600_cpld_attributes[] = {
+  &sensor_dev_attr_board_version.dev_attr.attr,
+  &sensor_dev_attr_cpld_version.dev_attr.attr,
+  &sensor_dev_attr_raw_access.dev_attr.attr,
+  /* reset attributes */
+  &sensor_dev_attr_system_reset.dev_attr.attr,
+  /* bootup status */
+  &sensor_dev_attr_bootup_status.dev_attr.attr,
+  /* psu attributes*/
+  DECLARE_PSU_ATTR(1),
+  DECLARE_PSU_ATTR(2),
+  /* piu present */	
+  &sensor_dev_attr_piu1_present.dev_attr.attr,
+  &sensor_dev_attr_piu2_present.dev_attr.attr,
+  /* sfp attributes */	
+  DECLARE_SFP_ATTR(1),
+  DECLARE_SFP_ATTR(2),
+  &sensor_dev_attr_usb_pwr_fault.dev_attr.attr,
+  &sensor_dev_attr_board_pwr_good.dev_attr.attr,
+  &sensor_dev_attr_piu_mgmt_pwr_good.dev_attr.attr,  
+  NULL
+};
+
+static const struct attribute_group t600_cpld_group = {
+	.attrs = t600_cpld_attributes,
+};
+
+static int t600_cpld_read(struct i2c_client *client, u8 reg)
+{
+      int status = 0, retry = I2C_RW_RETRY_COUNT;
+      while (retry) {
+          status = i2c_smbus_read_byte_data(client, reg);
+          if (unlikely(status < 0)) {
+	     msleep(I2C_RW_RETRY_INTERVAL);
+	     retry--;
+	     continue;
+	 }
+	 break;
+      }
+      return status;
+}
+
+static int t600_cpld_write(struct i2c_client *client, u8 reg, u8 value)
+{
+	int status = 0, retry = I2C_RW_RETRY_COUNT;
+	while (retry) {
+           status = i2c_smbus_write_byte_data(client, reg, value);
+	   if (unlikely(status < 0)) {
+	          msleep(I2C_RW_RETRY_INTERVAL);
+		  retry--;
+		  continue;
+	   }
+	   break;
+	}
+        return status;
+}
+
+
+static ssize_t show_version(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+        struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+        int status = 0;
+
+	u8 reg = 0, mask = 0;
+        struct i2c_client *client = to_i2c_client(dev);
+        struct t600_cpld_data *data = i2c_get_clientdata(client);
+	switch (attr->index) {
+	case BOARD_VERSION:
+		reg  = BOARD_REV_REG;
+		mask = 0x07;
+		break;
+	case CPLD_VERSION:
+		reg  = CPLD_VER_REG;
+		mask = 0x0F;
+		break;
+	default:
+	        return 0; /* return 0 if attr->index is out of range */
+		break;
+	}
+        mutex_lock(&data->update_lock);
+	status = t600_cpld_read(client, reg);
+	if (unlikely(status < 0)) {
+		goto exit;
+	}
+	mutex_unlock(&data->update_lock);
+	return sprintf(buf, "%d\n", (status & mask));
+exit:
+	mutex_unlock(&data->update_lock);
+	return status;	
+
+	
+}
+static ssize_t raw_access(struct device *dev, struct device_attribute *da,
+			const char *buf, size_t count)
+{
+	u32 addr, val;	
+        int status;
+        struct i2c_client *client = to_i2c_client(dev);
+        struct t600_cpld_data *data = i2c_get_clientdata(client);
+
+	if (sscanf(buf, "0x%x 0x%x", &addr, &val) != 2) {
+		return -EINVAL;
+	}
+
+	if (addr > 0xFF || val > 0xFF) {
+		return -EINVAL;
+	}
+
+	mutex_lock(&data->update_lock);
+	status = t600_cpld_write(client, addr, val);
+	if (unlikely(status < 0)) {
+		goto exit;
+	}
+	mutex_unlock(&data->update_lock);
+	return count;
+exit:
+	mutex_unlock(&data->update_lock);
+	return status;	
+
+
+}
+//TBD Function
+static ssize_t reset(struct device *dev, struct device_attribute *da,
+			const char *buf, size_t count)
+{
+	int status, reset;
+	
+	u8 reg = 0, regval=0;
+        struct i2c_client *client = to_i2c_client(dev);
+        struct t600_cpld_data *data = i2c_get_clientdata(client);
+//        struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+
+	status = kstrtoint(buf, 10, &reset);
+	if (status) {
+		return status;
+	}
+		
+	if (reset < 1 || reset > 2) {  // reset 1 means cold reset, 2 means warm reset 
+		                       // H/W comment add the R/W register  for "reset-all", "reset-CPU"
+		return -EINVAL;
+	}
+
+        //regval will depend on reset type to be set accordingly
+        //Might need to read the original one to modify too
+        //TBD        
+	status = t600_cpld_write(client, reg, regval);
+	if (unlikely(status < 0)) {
+		goto exit;
+	}
+	mutex_unlock(&data->update_lock);
+	return count;
+
+exit:
+	mutex_unlock(&data->update_lock);
+	return status;
+}
+//TBD Function
+static ssize_t show_reset_status(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+
+      int status = 0;
+
+      struct i2c_client *client = to_i2c_client(dev);
+      struct t600_cpld_data *data = i2c_get_clientdata(client);
+      u8 reg = 0, mask = 0;
+
+      mutex_lock(&data->update_lock);
+      status = t600_cpld_read(client, reg);   //H/W comment add the R/W register  for "reset-all", "reset-CPU"
+      if (unlikely(status < 0)) {
+		goto exit;
+      }
+      mutex_unlock(&data->update_lock);
+      //TBD need to read the R/W register and change the value to be return
+      
+      return sprintf(buf, "%d\n", (status & mask));
+       
+exit:
+      mutex_unlock(&data->update_lock);
+      return status;      
+
+}
+
+static ssize_t show_bootstatus(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+        int status = 0;
+
+        struct i2c_client *client = to_i2c_client(dev);
+        struct t600_cpld_data *data = i2c_get_clientdata(client);
+        mutex_lock(&data->update_lock);
+	status = t600_cpld_read(client, BOOT_STATUS_REG);
+	if (unlikely(status < 0)) {
+		goto exit;
+	}
+	mutex_unlock(&data->update_lock);
+	return sprintf(buf, "%d\n", (status & 0x03));  //BIT_1 WARM BOOT=2, BIT_0 COLD BOOT=1 
+exit:
+	mutex_unlock(&data->update_lock);
+	return status;	
+
+
+}
+static ssize_t show_psu(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+      int value = 0;
+      struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+         
+      int status = 0, mask = 0; 
+      struct i2c_client *client = to_i2c_client(dev);
+      struct t600_cpld_data *data = i2c_get_clientdata(client);
+      mutex_lock(&data->update_lock);
+      status = t600_cpld_read(client, PSU_STATUS_REG);
+      if (unlikely(status < 0)) {
+	  goto exit;
+      }
+      mutex_unlock(&data->update_lock);
+
+      switch (attr->index) {
+	      case PSU1_PRESENT:
+	      case PSU2_PRESENT:
+			if (attr->index - PSU1_PRESENT) 
+			    mask = 0x1; 
+			else
+			    mask = 0x8;			
+			if (status & mask)
+	                   value = 0;
+	                else
+	                   value = 1;    /* cpld val=0: present*/
+	                break;  	
+	      case PSU1_OUTPUT_GOOD:
+	      case PSU2_OUTPUT_GOOD:
+			if (attr->index - PSU1_OUTPUT_GOOD) 
+			    mask = 0x2; 
+			else
+			    mask = 0x10;
+			    
+			if (status & mask)
+	                   value = 1;
+	                else
+	                   value = 0;	
+			break;
+	      case PSU1_ALARM:
+	      case PSU2_ALARM:
+			if (attr->index - PSU1_ALARM) 
+			    mask = 0x4; 
+			else
+			    mask = 0x20;			    
+			if (status & mask)
+	                    value = 0;  /* cpld val=1: PSU works normal */
+	                else
+	                    value = 1;
+			    
+			break;
+	      default:
+			return 0;
+	}
+			    	    
+        return sprintf(buf, "%d\n", value);
+exit:
+	mutex_unlock(&data->update_lock);
+	return status;
+	
+}
+
+static ssize_t show_piu(struct device *dev, struct device_attribute *da
+                        ,char *buf)
+{
+    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+    int value = 0;
+    int status = 0; 
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_cpld_data *data = i2c_get_clientdata(client);
+    mutex_lock(&data->update_lock);
+    status = t600_cpld_read(client, PIU_STATUS_REG);
+    if (unlikely(status < 0)) {
+		goto exit;
+    }
+    mutex_unlock(&data->update_lock);
+
+    switch (attr->index) {
+	    case PIU1_PRESENT:
+	    case PIU2_PRESENT:
+		 value = !(status >> (1-(attr->index - PIU1_PRESENT)) & 0x1);
+		 break;;
+	    default:
+		return 0;
+    }
+    return sprintf(buf, "%d\n", value);
+
+exit:
+    mutex_unlock(&data->update_lock);
+    return status;     
+
+}
+
+static ssize_t show_sfp(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+    int value = 0;
+      
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_cpld_data *data = i2c_get_clientdata(client);
+    int status = 0,mask = 0;
+    u8 reg=0;
+    
+    switch (attr->index) {
+	case SFP1_PWR:  /* BIT_1 SFP1_PWR BIT_2 SFP2_PWR */ 
+	case SFP2_PWR:
+	   if (attr->index - SFP1_PWR) 
+	       mask = 0x04; 
+	   else
+	       mask = 0x02;
+	   reg = SFP_PWR_REG;
+	   break;
+
+	default:
+	   return 0;
+	   break;
+    }
+    mutex_lock(&data->update_lock);
+    status = t600_cpld_read(client, reg);
+    if (unlikely(status < 0)) {
+	goto exit;
+    }
+    mutex_unlock(&data->update_lock);
+    if (status & mask)
+	  value = 1;
+    else
+	  value = 0;	       	       
+	    
+    return sprintf(buf, "%d\n", value);
+exit:
+    mutex_unlock(&data->update_lock);
+    return status;    
+   
+
+}
+
+static ssize_t set_sfp_power(struct device *dev, struct device_attribute *da,
+                        const char *buf, size_t count)
+{
+    int status = 0, sfp_power = 0;
+    u8 reg = 0, regval=0, mask = 0;
+    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+    struct i2c_client *client = to_i2c_client(dev);
+    struct t600_cpld_data *data = i2c_get_clientdata(client);
+
+    status = kstrtoint(buf, 10, &sfp_power);
+    if (status) {
+        return status;
+    }
+
+    if (sfp_power != 0 && sfp_power != 1) {
+            return -EINVAL;
+    }
+
+    switch (attr->index) {
+        case SFP1_PWR:  /* BIT_1 SFP1_PWR BIT_2 SFP2_PWR */
+        case SFP2_PWR:
+           if (attr->index - SFP1_PWR)
+               mask = 0x04;
+           else
+               mask = 0x02;
+           reg = SFP_PWR_REG;
+           break;
+
+        default:
+           return 0;
+           break;
+    }
+
+    mutex_lock(&data->update_lock);
+
+    status = t600_cpld_read(client, reg);
+    if (unlikely(status < 0)) {
+        goto exit;
+    }
+
+    if (sfp_power == 1)   /* enable sfp power */
+        regval = status | mask;
+    else
+        regval = status & (~mask);
+
+    status = t600_cpld_write(client, reg, regval);
+    if (unlikely(status < 0)) {
+        goto exit;
+    }
+
+    mutex_unlock(&data->update_lock);
+    return count;
+
+exit:
+    mutex_unlock(&data->update_lock);
+    return status;
+}
+
+
+static ssize_t show_pwr_status(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+        struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+        int status = 0;
+
+	u8 reg = 0, mask = 0;
+        struct i2c_client *client = to_i2c_client(dev);
+        struct t600_cpld_data *data = i2c_get_clientdata(client);
+	switch (attr->index) {
+	case USB_PWR_FAULT:
+		reg  = USB_PG_REG;
+		mask = 0x01;
+		break;
+	case BOARD_PWR_GOOD:
+		reg  = BOARD_PG_REG;
+		mask = 0x01;
+		break;
+	case PIU_MGMT_PWR_GOOD:
+		reg  = PIU_MGMT_PG_REG;
+		mask = 0x01;
+		break;		
+	default:
+	        return 0;
+		break;
+	}
+        mutex_lock(&data->update_lock);
+	status = t600_cpld_read(client, reg);
+	if (unlikely(status < 0)) {
+		goto exit;
+	}
+	mutex_unlock(&data->update_lock);	
+	if (USB_PG_REG == reg)
+	   return sprintf(buf, "%d\n", !(status & mask)); // read 0 is usb_pwr_fault T, 1 usb_pwr_fault F
+	else
+	   return sprintf(buf, "%d\n", (status & mask));
+exit:
+	mutex_unlock(&data->update_lock);
+	return status;	
+
+	
+}
+
+static int t600_cpld_probe(struct i2c_client *client,
+            const struct i2c_device_id *dev_id)
+{
+  int status;
+  struct t600_cpld_data *data = NULL;
+
+  if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+      dev_dbg(&client->dev, "i2c_check_functionality failed (0x%x)\n", client->addr);
+      status = -EIO;
+      goto exit;
+  }
+
+  data = kzalloc(sizeof(struct t600_cpld_data), GFP_KERNEL);
+  if (!data) {
+      status = -ENOMEM;
+      goto exit;
+  }
+
+  i2c_set_clientdata(client, data);
+  mutex_init(&data->update_lock);
+  dev_info(&client->dev, "chip found\n");
+
+   /* Register sysfs hooks */
+   status = sysfs_create_group(&client->dev.kobj, &t600_cpld_group);
+   if (status) {
+	goto exit_free;
+   }
+
+   data->hwmon_dev = hwmon_device_register(&client->dev);
+   if (IS_ERR(data->hwmon_dev)) {
+	status = PTR_ERR(data->hwmon_dev);
+	goto exit_remove;
+   }
+
+   dev_info(&client->dev, "%s: cpld '%s'\n",
+		 dev_name(data->hwmon_dev), client->name);
+
+    return 0;
+
+exit_remove:
+    sysfs_remove_group(&client->dev.kobj, &t600_cpld_group);
+exit_free:
+    kfree(data);
+exit:
+    
+    return status;
+}
+
+static int t600_cpld_remove(struct i2c_client *client)
+{
+  struct t600_cpld_data *data = i2c_get_clientdata(client);
+
+  hwmon_device_unregister(data->hwmon_dev);
+  sysfs_remove_group(&client->dev.kobj, &t600_cpld_group);
+  kfree(data);
+
+  return 0;
+}
+
+static const struct i2c_device_id t600_cpld_id[] = {
+    { DRVNAME, 0 },
+    {}
+};
+MODULE_DEVICE_TABLE(i2c, t600_cpld_id);
+
+static struct i2c_driver t600_cpld_driver = {
+    .class        = I2C_CLASS_HWMON,
+    .driver = {
+        .name     = DRVNAME,
+    },
+    .probe        = t600_cpld_probe,
+    .remove       = t600_cpld_remove,
+    .id_table     = t600_cpld_id,
+    .address_list = normal_i2c,
+};
+
+module_i2c_driver(t600_cpld_driver);
+
+MODULE_AUTHOR("Vic Lin <vic_lin@accton.com.tw>");
+MODULE_DESCRIPTION("t600 cpld driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/hwmon/accton_t600_fan.c b/drivers/hwmon/accton_t600_fan.c
new file mode 100644
index 0000000..b96b282
--- /dev/null
+++ b/drivers/hwmon/accton_t600_fan.c
@@ -0,0 +1,605 @@
+/*
+ * A hwmon driver for the Accton t600 fan cpld
+ *
+ * Copyright (C) 2014 Accton Technology Corporation.
+ * Brandon Chuang <brandon_chuang@accton.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/sysfs.h>
+#include <linux/slab.h>
+#include <linux/delay.h>  //msleep
+
+#define DRVNAME "t600_fan"
+
+static struct t600_fan_data *t600_fan_update_device(struct device *dev);					
+static ssize_t fan_show_value(struct device *dev, struct device_attribute *da, char *buf);
+static ssize_t set_duty_cycle(struct device *dev, struct device_attribute *da,
+			const char *buf, size_t count);
+
+static ssize_t set_fan_enable(struct device *dev, struct device_attribute *da,
+			const char *buf, size_t count);
+
+static ssize_t raw_access(struct device *dev, struct device_attribute *da,
+			const char *buf, size_t count);				
+			
+/* fan related data, the index should match sysfs_fan_attributes */
+static const u8 fan_reg[] = {
+	0x01,      /* fan cpld version */
+	0x0F,	   /* fan 1-6 present status */
+	0x10,	   /* fan 1-6 direction(0:B2F 1:F2B) */
+	0x11,	   /* fan PWM(for all fan) */
+	0x12,	   /* front fan 1 speed(rpm) */
+	0x13,	   /* front fan 2 speed(rpm) */
+	0x14,	   /* front fan 3 speed(rpm) */
+	0x15,	   /* front fan 4 speed(rpm) */
+	0x16,	   /* front fan 5 speed(rpm) */
+	0x22,	   /* rear fan 1 speed(rpm) */
+	0x23,	   /* rear fan 2 speed(rpm) */
+	0x24,	   /* rear fan 3 speed(rpm) */
+	0x25,	   /* rear fan 4 speed(rpm) */
+	0x26,	   /* rear fan 5 speed(rpm) */
+	0x30,      /* fan power enable */
+};
+
+/* Each client has this additional data */
+struct t600_fan_data {
+	struct device   *hwmon_dev;
+	struct mutex	 update_lock;
+	char		valid;		   /* != 0 if registers are valid */
+	unsigned long	last_updated;	/* In jiffies */
+	u8		reg_val[ARRAY_SIZE(fan_reg)]; /* Register value */
+};
+
+#define FAN_PRESENT_ATTR_ID(index)		FAN##index##_PRESENT
+#define FAN_ENABLE_ATTR_ID(index)		FAN##index##_ENABLE
+#define FAN_FAULT_ATTR_ID(index)		FAN##index##_FAULT
+#define FAN_1_INPUT_ATTR_ID(index)		FAN##index##_1_INPUT
+#define FAN_2_INPUT_ATTR_ID(index)		FAN##index##_2_INPUT
+#define FAN_DIRECTION_ATTR_ID(index)            FAN##index##_DIRECTION
+
+enum fan_id {
+	FAN1_ID,
+	FAN2_ID,
+	FAN3_ID,
+	FAN4_ID,
+	FAN5_ID,
+	NUM_OF_FAN
+};
+enum sysfs_fan_attributes {
+	CPLD_VERSION,           /* fan cpld version */
+	FAN_PRESENT_REG,
+	FAN_DIRECTION_REG,
+	FAN_PWM1,	        /* FAN PWM (for all fan) */	
+	FAN_1_INPUT_ATTR_ID(1),	/* front fan X speed(rpm) */
+	FAN_1_INPUT_ATTR_ID(2),
+	FAN_1_INPUT_ATTR_ID(3),
+	FAN_1_INPUT_ATTR_ID(4),
+	FAN_1_INPUT_ATTR_ID(5),
+	FAN_2_INPUT_ATTR_ID(1),	/* rear fan X speed(rpm) */
+	FAN_2_INPUT_ATTR_ID(2),
+	FAN_2_INPUT_ATTR_ID(3),
+	FAN_2_INPUT_ATTR_ID(4),
+	FAN_2_INPUT_ATTR_ID(5),		
+	FAN_ENABLE_REG,
+	ACCESS,	                /* access cpld register */	
+	FAN_ENABLE_ATTR_ID(1),  /* FAN X control switch */
+	FAN_ENABLE_ATTR_ID(2),
+	FAN_ENABLE_ATTR_ID(3),
+	FAN_ENABLE_ATTR_ID(4),
+	FAN_ENABLE_ATTR_ID(5),
+	FAN_FAULT_ATTR_ID(1),	/* FAN X fault status */
+	FAN_FAULT_ATTR_ID(2),
+	FAN_FAULT_ATTR_ID(3),
+	FAN_FAULT_ATTR_ID(4),
+	FAN_FAULT_ATTR_ID(5),
+        FAN_PRESENT_ATTR_ID(1), /* fan X present */
+        FAN_PRESENT_ATTR_ID(2),
+        FAN_PRESENT_ATTR_ID(3),
+        FAN_PRESENT_ATTR_ID(4),
+        FAN_PRESENT_ATTR_ID(5),
+        FAN_DIRECTION_ATTR_ID(1), /* fan X direction*/
+        FAN_DIRECTION_ATTR_ID(2),
+        FAN_DIRECTION_ATTR_ID(3),
+        FAN_DIRECTION_ATTR_ID(4),
+        FAN_DIRECTION_ATTR_ID(5)
+};
+
+/* Define attributes */
+#define DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(index) \
+	static SENSOR_DEVICE_ATTR(fan##index##_fault, S_IRUGO, fan_show_value, NULL, FAN##index##_FAULT)
+#define DECLARE_FAN_FAULT_ATTR(index)	  &sensor_dev_attr_fan##index##_fault.dev_attr.attr
+
+#define DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(index) \
+	static SENSOR_DEVICE_ATTR(fan##index##_direction, S_IRUGO, fan_show_value, NULL, FAN##index##_DIRECTION)
+#define DECLARE_FAN_DIRECTION_ATTR(index)  &sensor_dev_attr_fan##index##_direction.dev_attr.attr
+
+#define DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(index) \
+	static SENSOR_DEVICE_ATTR(fan##index##_present, S_IRUGO, fan_show_value, NULL, FAN##index##_PRESENT)
+#define DECLARE_FAN_PRESENT_ATTR(index)	  &sensor_dev_attr_fan##index##_present.dev_attr.attr
+
+#define DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(index) \
+	static SENSOR_DEVICE_ATTR(fan##index##_1_input, S_IRUGO, fan_show_value, NULL, FAN##index##_1_INPUT);\
+	static SENSOR_DEVICE_ATTR(fan##index##_2_input, S_IRUGO, fan_show_value, NULL, FAN##index##_2_INPUT)
+#define DECLARE_FAN_SPEED_RPM_ATTR(index)  &sensor_dev_attr_fan##index##_1_input.dev_attr.attr, \
+	  								   &sensor_dev_attr_fan##index##_2_input.dev_attr.attr
+
+static SENSOR_DEVICE_ATTR(cpld_version, S_IRUGO, fan_show_value, NULL, CPLD_VERSION);
+
+static SENSOR_DEVICE_ATTR(raw_access, S_IWUSR | S_IRUGO, NULL, raw_access, ACCESS);
+
+#define DECLARE_FAN_DUTY_CYCLE_SENSOR_DEV_ATTR(index) \
+	static SENSOR_DEVICE_ATTR(pwm##index, S_IWUSR | S_IRUGO, fan_show_value, set_duty_cycle, FAN_PWM1)
+#define DECLARE_FAN_DUTY_CYCLE_ATTR(index) &sensor_dev_attr_pwm##index.dev_attr.attr
+
+/* fanX enable attribute */
+#define DECLARE_FAN_ENABLE_SENSOR_DEV_ATTR(index) \
+	static SENSOR_DEVICE_ATTR(fan##index##_enable, S_IWUSR | S_IRUGO, fan_show_value, set_fan_enable, FAN##index##_ENABLE)
+#define DECLARE_FAN_ENABLE_ATTR(index)	  &sensor_dev_attr_fan##index##_enable.dev_attr.attr
+
+
+/* 5 fan fault attributes in this platform */
+DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(1);
+DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(2);
+DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(3);
+DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(4);
+DECLARE_FAN_FAULT_SENSOR_DEV_ATTR(5);
+/* 5 fan direction attribute in this platform */
+DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(1);  
+DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(2);  
+DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(3);  
+DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(4);  
+DECLARE_FAN_DIRECTION_SENSOR_DEV_ATTR(5);  
+/* 5 fan speed(rpm) attributes in this platform */
+DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(1);
+DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(2);
+DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(3);
+DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(4);
+DECLARE_FAN_SPEED_RPM_SENSOR_DEV_ATTR(5);
+/* 5 fan present attributes in this platform */
+DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(1);
+DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(2);
+DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(3);
+DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(4);
+DECLARE_FAN_PRESENT_SENSOR_DEV_ATTR(5);
+/* 1 fan duty cycle attribute in this platform */
+DECLARE_FAN_DUTY_CYCLE_SENSOR_DEV_ATTR(1);
+/* 5 fan enable attributes in this platform */
+DECLARE_FAN_ENABLE_SENSOR_DEV_ATTR(1);
+DECLARE_FAN_ENABLE_SENSOR_DEV_ATTR(2);
+DECLARE_FAN_ENABLE_SENSOR_DEV_ATTR(3);
+DECLARE_FAN_ENABLE_SENSOR_DEV_ATTR(4);
+DECLARE_FAN_ENABLE_SENSOR_DEV_ATTR(5);
+
+static struct attribute *t600_fan_attributes[] = {
+	&sensor_dev_attr_cpld_version.dev_attr.attr,
+	&sensor_dev_attr_raw_access.dev_attr.attr,	
+	DECLARE_FAN_ENABLE_ATTR(1),
+	DECLARE_FAN_ENABLE_ATTR(2),
+	DECLARE_FAN_ENABLE_ATTR(3),
+	DECLARE_FAN_ENABLE_ATTR(4),
+	DECLARE_FAN_ENABLE_ATTR(5),	
+	DECLARE_FAN_DUTY_CYCLE_ATTR(1),	
+	/* fan related attributes */
+	DECLARE_FAN_FAULT_ATTR(1),
+	DECLARE_FAN_FAULT_ATTR(2),
+	DECLARE_FAN_FAULT_ATTR(3),
+	DECLARE_FAN_FAULT_ATTR(4),
+	DECLARE_FAN_FAULT_ATTR(5),
+	DECLARE_FAN_DIRECTION_ATTR(1),
+	DECLARE_FAN_DIRECTION_ATTR(2),
+	DECLARE_FAN_DIRECTION_ATTR(3),
+	DECLARE_FAN_DIRECTION_ATTR(4),
+	DECLARE_FAN_DIRECTION_ATTR(5),
+	DECLARE_FAN_SPEED_RPM_ATTR(1),
+	DECLARE_FAN_SPEED_RPM_ATTR(2),
+	DECLARE_FAN_SPEED_RPM_ATTR(3),
+	DECLARE_FAN_SPEED_RPM_ATTR(4),
+	DECLARE_FAN_SPEED_RPM_ATTR(5),
+	DECLARE_FAN_PRESENT_ATTR(1),
+	DECLARE_FAN_PRESENT_ATTR(2),
+	DECLARE_FAN_PRESENT_ATTR(3),
+	DECLARE_FAN_PRESENT_ATTR(4),
+	DECLARE_FAN_PRESENT_ATTR(5),	
+	NULL
+};
+
+#define FAN_DUTY_CYCLE_REG_MASK			0x0F
+#define FAN_MAX_DUTY_CYCLE			255
+#define FAN_REG_VAL_TO_SPEED_RPM_STEP   	100
+#define FAN_MAX_WATCHDOG_SECONDS		255
+#define I2C_RW_RETRY_COUNT			10
+#define I2C_RW_RETRY_INTERVAL			60 /* ms */
+
+static int t600_fan_read_value(struct i2c_client *client, u8 reg)
+{
+	int status = 0, retry = I2C_RW_RETRY_COUNT;
+
+	while (retry) {
+		status = i2c_smbus_read_byte_data(client, reg);
+		if (unlikely(status < 0)) {
+			msleep(I2C_RW_RETRY_INTERVAL);
+			retry--;
+			continue;
+		}
+
+		break;
+	}
+
+    return status;
+}
+static int t600_fan_write_value(struct i2c_client *client, u8 reg, u8 value)
+{
+	int status = 0, retry = I2C_RW_RETRY_COUNT;
+
+	while (retry) {
+		status = i2c_smbus_write_byte_data(client, reg, value);
+		if (unlikely(status < 0)) {
+			msleep(I2C_RW_RETRY_INTERVAL);
+			retry--;
+			continue;
+		}
+
+		break;
+	}
+
+    return status;
+}
+
+/* fan utility functions */
+static u32 reg_val_to_duty_cycle(u8 reg_val) 
+{
+	reg_val &= FAN_DUTY_CYCLE_REG_MASK;
+	return ((u32) reg_val * 39)/100;
+}
+static u8 duty_cycle_to_reg_val(u8 duty_cycle) 
+{
+
+	return ((u32) duty_cycle * 100) / 39;
+}
+static u32 reg_val_to_speed_rpm(u8 reg_val)
+{
+	return (u32)reg_val * FAN_REG_VAL_TO_SPEED_RPM_STEP;
+}
+static u8 reg_val_to_direction(u8 reg_val, enum fan_id id)
+{
+	u8 mask = (1 << id);
+
+	reg_val &= mask;
+
+	return reg_val ? 1 : 0;
+}
+static u8 reg_val_to_is_present(u8 reg_val, enum fan_id id)
+{
+	u8 mask = (1 << id);
+
+	reg_val &= mask;
+
+	return reg_val ? 0 : 1;
+}
+static u8 reg_val_to_is_enable(u8 reg_val, enum fan_id id)
+{
+	u8 mask = (1 << id);
+
+	reg_val &= mask;
+
+	return reg_val ? 1 : 0;
+}
+static u8 is_fan_failed(struct t600_fan_data *data, enum fan_id id)
+{
+	u8 ret = 1;
+	int front_fan_index = FAN_1_INPUT_ATTR_ID(1) + id;
+	int rear_fan_index  = FAN_2_INPUT_ATTR_ID(1)  + id;
+
+	/* Check if the speed of front or rear fan is ZERO,  
+	 */
+	if (reg_val_to_speed_rpm(data->reg_val[front_fan_index]) &&
+		reg_val_to_speed_rpm(data->reg_val[rear_fan_index]))  {
+		ret = 0;
+	}
+	return ret;
+}
+static int fan_set_duty_cycle_to_cpld(struct i2c_client *client, int new_duty_cycle)
+{
+	struct t600_fan_data *data = i2c_get_clientdata(client);
+	u8 reg = fan_reg[0x3];
+	int ret;
+	
+	if (new_duty_cycle < 0 || new_duty_cycle > 255) {
+		new_duty_cycle = 255;
+	}
+#if 0 //No watchdog 	
+	/* Disable the watchdog timer
+	 */
+	ret = t600_fan_write_value(client, 0x33, 0);
+	
+	if (ret != 0) {
+		dev_dbg(&client->dev, "Unable to disable the watchdog timer\n");
+		return ret;
+	}
+#endif	
+	/* Update duty cycle
+	 */
+	mutex_lock(&data->update_lock);
+	data->reg_val[FAN_PWM1] = new_duty_cycle;
+	ret = t600_fan_write_value(client, reg, new_duty_cycle);
+	mutex_unlock(&data->update_lock);
+	
+	return ret;
+}
+static ssize_t set_duty_cycle(struct device *dev, struct device_attribute *da,
+			const char *buf, size_t count) 
+{
+	int error, value;
+	struct i2c_client *client = to_i2c_client(dev);
+	
+	error = kstrtoint(buf, 10, &value);
+	if (error) {
+		return error;
+	}
+		
+	if (value < 0 || value > FAN_MAX_DUTY_CYCLE) {
+		return -EINVAL;
+	}
+	
+	fan_set_duty_cycle_to_cpld(client, duty_cycle_to_reg_val(value));
+	
+	return count;
+}
+static int fan_set_enable_to_cpld(struct i2c_client *client, u8 reg, int index, int new_value)
+{
+	struct t600_fan_data *data = i2c_get_clientdata(client);
+	int ret;
+				
+	mutex_lock(&data->update_lock);
+        data->reg_val[index] = new_value;
+	ret = t600_fan_write_value(client, reg, new_value);
+	mutex_unlock(&data->update_lock);
+	
+	return ret;
+}
+static ssize_t set_fan_enable(struct device *dev, struct device_attribute *da, const char *buf, size_t count) 
+{
+	int error, value, index;
+	u8 reg = 0, mask = 0;
+	int regval;
+        struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct t600_fan_data *data = i2c_get_clientdata(client);
+
+	error = kstrtoint(buf, 10, &value);
+	if (error) {
+		return error;
+	}
+		
+	if (value < 0 || value > 1) {
+		return -EINVAL;
+	}
+	reg  = fan_reg[FAN_ENABLE_REG];
+	regval = data->reg_val[FAN_ENABLE_REG];
+	mask = 0x1 << (attr->index - FAN1_ENABLE);
+	regval = value ? (regval | mask) : (regval & ~mask);	
+	index = FAN_ENABLE_REG;
+	fan_set_enable_to_cpld(client, reg, index, regval);
+
+	return count;
+}
+
+static ssize_t raw_access(struct device *dev, struct device_attribute *da,
+			const char *buf, size_t count)
+{
+	u32 addr, val;
+	
+        int status;
+        struct i2c_client *client = to_i2c_client(dev);
+        struct t600_fan_data *data = i2c_get_clientdata(client);
+
+	if (sscanf(buf, "0x%x 0x%x", &addr, &val) != 2) {
+		return -EINVAL;
+	}
+
+	if (addr > 0xFF || val > 0xFF) {
+		return -EINVAL;
+	}
+
+	mutex_lock(&data->update_lock);
+	status = t600_fan_write_value(client, addr, val);
+	if (unlikely(status < 0)) {
+		goto exit;
+	}
+	mutex_unlock(&data->update_lock);
+	return count;
+exit:
+	mutex_unlock(&data->update_lock);
+	return status;	
+
+
+}
+static ssize_t fan_show_value(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct t600_fan_data *data = t600_fan_update_device(dev);
+	ssize_t ret = 0;
+	
+	if (data->valid) {
+		switch (attr->index) {
+			case FAN_PWM1:
+			{
+				u32 duty_cycle = reg_val_to_duty_cycle(data->reg_val[FAN_PWM1]);
+				ret = sprintf(buf, "%u\n", duty_cycle);
+				break;
+			}
+			case FAN_1_INPUT_ATTR_ID(1)...FAN_2_INPUT_ATTR_ID(5):			
+				ret = sprintf(buf, "%u\n", reg_val_to_speed_rpm(data->reg_val[attr->index]));
+				break;
+			case FAN_DIRECTION_ATTR_ID(1)...FAN_DIRECTION_ATTR_ID(5):
+				ret = sprintf(buf, "%d\n", 
+							  reg_val_to_direction(data->reg_val[FAN_DIRECTION_REG],
+							  attr->index - FAN_DIRECTION_ATTR_ID(1) ));
+                        							  
+				break;
+			case FAN_PRESENT_ATTR_ID(1)...FAN_PRESENT_ATTR_ID(5):
+				ret = sprintf(buf, "%d\n",
+							  reg_val_to_is_present(data->reg_val[FAN_PRESENT_REG],
+							  attr->index - FAN_PRESENT_ATTR_ID(1) ));				  
+				break;
+			case FAN_FAULT_ATTR_ID(1)...FAN_FAULT_ATTR_ID(5):
+				ret = sprintf(buf, "%d\n", is_fan_failed(data, attr->index - FAN_FAULT_ATTR_ID(1) ));
+				break;
+			case CPLD_VERSION:
+				ret = sprintf(buf, "%d\n", data->reg_val[CPLD_VERSION]);
+				break;
+
+			case FAN_ENABLE_ATTR_ID(1)...FAN_ENABLE_ATTR_ID(5):
+				ret = sprintf(buf, "%d\n",
+							  reg_val_to_is_enable(data->reg_val[FAN_ENABLE_REG],
+							  attr->index - FAN_ENABLE_ATTR_ID(1) ));
+				break; 						
+			default:
+				break;
+		}		
+	}
+	
+	return ret;
+}
+
+static const struct attribute_group t600_fan_group = {
+	.attrs = t600_fan_attributes,
+};
+
+static struct t600_fan_data *t600_fan_update_device(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct t600_fan_data *data = i2c_get_clientdata(client);
+
+	mutex_lock(&data->update_lock);
+
+	if (time_after(jiffies, data->last_updated + HZ + HZ / 2) || 
+		!data->valid) {
+		int i;
+
+		dev_dbg(&client->dev, "Starting t600_fan update\n");
+		data->valid = 0;
+		
+		/* Update fan data
+		 */
+		for (i = 0; i < ARRAY_SIZE(data->reg_val); i++) {
+			int status = t600_fan_read_value(client, fan_reg[i]);
+			
+			if (status < 0) {
+				printk(KERN_INFO "reg %d, err %d\r\n", fan_reg[i], status);
+				dev_dbg(&client->dev, "reg %d, err %d\n", fan_reg[i], status);
+				goto exit;
+			}
+			else {
+				data->reg_val[i] = status;
+			}
+		}
+		data->last_updated = jiffies;
+		data->valid = 1;
+	}
+
+exit:	
+	mutex_unlock(&data->update_lock);
+
+	return data;
+}
+
+static int t600_fan_probe(struct i2c_client *client,
+			const struct i2c_device_id *dev_id)
+{
+	struct t600_fan_data *data;
+	int status;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		status = -EIO;
+		goto exit;
+	}
+	data = kzalloc(sizeof(struct t600_fan_data), GFP_KERNEL);
+	if (!data) {
+		status = -ENOMEM;
+		goto exit;
+	}
+	i2c_set_clientdata(client, data);
+	data->valid = 0;
+	mutex_init(&data->update_lock);
+
+	dev_info(&client->dev, "chip found\n");
+
+	/* Register sysfs hooks */
+	status = sysfs_create_group(&client->dev.kobj, &t600_fan_group);
+	if (status) {
+		goto exit_free;
+	}
+	data->hwmon_dev = hwmon_device_register(&client->dev);
+	if (IS_ERR(data->hwmon_dev)) {
+		status = PTR_ERR(data->hwmon_dev);
+		goto exit_remove;
+	}
+
+	dev_info(&client->dev, "%s: fan '%s'\n",
+		 dev_name(data->hwmon_dev), client->name);
+
+	return 0;
+
+exit_remove:
+	sysfs_remove_group(&client->dev.kobj, &t600_fan_group);
+exit_free:
+	kfree(data);
+exit:
+	
+	return status;
+}
+static int t600_fan_remove(struct i2c_client *client)
+{
+	struct t600_fan_data *data = i2c_get_clientdata(client);
+	
+	hwmon_device_unregister(data->hwmon_dev);
+	sysfs_remove_group(&client->dev.kobj, &t600_fan_group);
+	kfree(data);
+	
+	return 0;
+}
+/* Addresses to scan */
+static const unsigned short normal_i2c[] = { I2C_CLIENT_END };
+static const struct i2c_device_id t600_fan_id[] = {
+	{ DRVNAME, 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, t600_fan_id);
+static struct i2c_driver t600_fan_driver = {
+	.class		= I2C_CLASS_HWMON,
+	.driver = {
+		.name	 = DRVNAME,
+	},
+	.probe		= t600_fan_probe,
+	.remove	   = t600_fan_remove,
+	.id_table	 = t600_fan_id,
+	.address_list = normal_i2c,
+};
+module_i2c_driver(t600_fan_driver);
+MODULE_AUTHOR("Vic Lin <vic_lin@accton.com.tw>");
+MODULE_DESCRIPTION("t600_fan driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index c2d3eb7..da4c926 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -10,6 +10,15 @@ config SENSORS_LIS3LV02D
 	select INPUT_POLLDEV
 	default n
 
+config ACCTON_T600_MDEC
+	tristate "Accton T600 PCI FPGA Device"
+	depends on PCI && SYSFS
+	help
+	  If you say yes here you get support for Accton t600 mdec FPGA.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called accton_t600_fj_mdec.
+
 config AD525X_DPOT
 	tristate "Analog Devices Digital Potentiometers"
 	depends on (I2C || SPI) && SYSFS
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 4f4e74b..58b80e4 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -3,6 +3,7 @@
 #
 
 obj-$(CONFIG_IBM_ASM)		+= ibmasm/
+obj-$(CONFIG_ACCTON_T600_MDEC)	+= accton_t600_fj_mdec.o
 obj-$(CONFIG_AD525X_DPOT)	+= ad525x_dpot.o
 obj-$(CONFIG_AD525X_DPOT_I2C)	+= ad525x_dpot-i2c.o
 obj-$(CONFIG_AD525X_DPOT_SPI)	+= ad525x_dpot-spi.o
diff --git a/drivers/misc/accton_t600_fj_mdec.c b/drivers/misc/accton_t600_fj_mdec.c
new file mode 100644
index 0000000..659a424
--- /dev/null
+++ b/drivers/misc/accton_t600_fj_mdec.c
@@ -0,0 +1,1009 @@
+/*-----------------------------------------------------------------------------
+ * FILE NAME: mdec_fpga.c
+ *-----------------------------------------------------------------------------
+ * PURPOSE:
+ *    This file provides the function to control resources of FPGA device.
+ *
+ * NOTES:
+ *    None.
+ *
+ * HISTORY:
+ *    09/07/2018(v0.04) - Roy Chuang, 1. Integrate with blade board R0A
+ *                                    2. Fixed endian issue
+ *                                    3. Fixed PCI bar address to BAR0
+ *    03/07/2018(v0.03) - Vincent Wang, 1. Update vendor and device ID(CDEC, MBCNT, MDEC) into driver's PCI table
+                                        2. Fixed some typo issue
+ *    26/06/2018(v0.02) - Vincent Wang, 1. Create MDEC EEPROM node. 
+ *                                      2. Remove redundancy of read_port_eeprom() function 
+ *    23/05/2018(v0.01) - Vincent Wang, Created.
+ * Copyright(C)           Accton Corporation, 2017-2018
+ *-----------------------------------------------------------------------------
+ */
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/pci.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/sysfs.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/unistd.h>
+#include <linux/delay.h>
+
+#define FPGA_MNG_I2C_WORKAROUND                                 0
+#define DRIVER_NAME                                             "fujitsu_mdec_fpga"
+#define DRIVER_DESCRIPTION_NAME                                 "Fujitsu FPGA PCI device driver"
+#define DRIVER_VERSION                                          "0.04"
+#define DRIVER_DEBUG_MESSAGE_LEVEL                              8
+#define DRIVER_MAX_BUFFER_LENGTH                                16
+#define DRIVER_MAX_STRING_LENGTH                                (DRIVER_MAX_BUFFER_LENGTH - 1)
+#define KERNEL_RESOLUTION_SCALAR                                1000
+#define MDIO_STATUS_CHK_RETRY_COUNT                             100
+#define MDIO_BUS_CHK_RETRY_COUNT                                5
+#define MDIO_SLEEP_TIME                                         30 /* micro second */
+#define MDIO_CHK_STATUS_RETRY_INTERVAL                          6 /* micro second */
+#define MDIO_WRITE_MODE                                         (0x0001)
+#define MDIO_READ_MODE                                          (0x0000)
+#define MDIO_STATUS_DONE                                        (0x0001)
+#define MDIO_DATA_SIZE_1                                        (0x0001)
+#define MDIO_DATA_SIZE_2                                        (0x0002)
+#define MDIO_WRITE_CMD1                                         0x000A  // 1010
+#define MDIO_WRITE_CMD2                                         0x0006  // 0110
+#define MDIO_READ_CMD1                                          0x0009  // 1001
+#define MDIO_READ_CMD2                                          0x0005  // 0101
+#define MDIO_BUS_CHK_OK                                         0x0000  // TBD
+#define MDIO_STATUS_BUSY                                        0x0001  // TBD
+
+// MDEC
+#define MDEC_WRITE_MODE                                         (0x0001)
+#define MDEC_READ_MODE                                          (0x0000)
+#define MDEC_EEPROM_SIZE                                        256 
+#define MDEC_EEPROM_ADDR                                        0x00F00000
+
+// I2C
+#define I2C_WRITE_MODE                                          (0x01)
+#define I2C_READ_MODE                                           (0x00)
+#define I2C_CHK_BUS_BUSY_RETRY_COUNT                            200
+#define I2C_READ_STATUS_RETRY_COUNT                             3
+#define I2C_ACC_CMD_WRITE                                       0x00000002
+#define I2C_ACC_CMD_READ                                        0x00000001
+
+// QSFP EEPROM
+#define QSFP_EEPROM_SIZE                                        256
+// port hex
+#define PORT1_HEX                                               0x00
+#define PORT2_HEX                                               0x01
+#define PORT3_HEX                                               0x02
+#define PORT4_HEX                                               0x03
+#define PORT5_HEX                                               0x04
+#define PORT6_HEX                                               0x05
+#define PORT7_HEX                                               0x06
+#define PORT8_HEX                                               0x07
+#define PORT9_HEX                                               0x08
+#define PORT10_HEX                                              0x09
+#define PORT11_HEX                                              0x0a
+#define PORT12_HEX                                              0x0b
+#define POS_127_HEX                                             0x7F
+
+enum fpga_register_map
+{
+    // CPLD VERSION
+    CPLD_VERSION        = 0x00000000, 
+    // MDIO Read Address
+    BMD_BUS_MDIO_SUB_RD_ADD = 0x00700140,
+    BMD_BUS_MDIO_RD_PDT = 0x00700144,  // MDIO bus bridge Read Address_Data
+    BMD_BUS_MDIO_RD_ADD = 0x00700144,
+    // MDIO Read Data 
+    BMD_BUS_MDIO_RD_DT  = 0x00700148,
+    // MDIO Write Address
+    BMD_BUS_MDIO_WT_PDT = 0x007001D4,  // MDIO BUS bridge write adress data
+    BMD_BUS_MDIO_WT_ADD = 0x007001D4,
+    BMD_BUS_MDIO_SUB_WT_ADD = 0x007001D0,
+    // MDIO Write Data
+    BMD_BUS_MDIO_WT_DT  = 0x007001D8,
+    // MDIO Command
+    BMD_BUS_ACC_CMD     = 0x00700134,
+    // MDIO Busy
+    BMD_BUS_BUSY        = 0x00700130,
+    // MDIO Error
+    BMD_AC_BUS_TAERR    = 0x00700120,
+    // MDEC HW Pin
+    HW_ModSelL          = 0x00A00024,
+    HW_LPMODE           = 0x00A00020,
+    HW_RESETL           = 0x00A00008,
+    HW_MODPRSL          = 0x00A00030,
+    HW_INTL             = 0x00A00010,
+    // MEDC I2C
+    I2C_WRITE_ADD       = 0x00A001D0,
+    I2C_WRITE_DT        = 0x00A001D4,
+    I2C_READ_ADD        = 0x00A00140,
+    I2C_READ_DT         = 0x00A00144,
+    I2C_ACC_CMD         = 0x00A00134,
+    I2C_BUSY            = 0x00A00130,
+    I2C_IRQ_ERR_HL      = 0x00A00120,
+    // MDEC
+    MDEC_EEPROM_ADD     = 0x00F00000,
+};
+
+enum fpga_sysfs_attributes
+{
+    CPLD_VERSION_ATTR, DCO_MDIO_OFFSET_ATTR, DCO_MDIO_ATTR, MDEC_OFFSET_ATTR, MDEC_ATTR, MDEC_EEPROM_ATTR, QSFP_OFFSET_ATTR, QSFP_ATTR, PORT1_EEPROM_0, PORT1_EEPROM_1, PORT1_EEPROM_2, PORT1_EEPROM_3,
+    PORT2_EEPROM_0, PORT2_EEPROM_1, PORT2_EEPROM_2, PORT2_EEPROM_3, PORT3_EEPROM_0, PORT3_EEPROM_1, PORT3_EEPROM_2, PORT3_EEPROM_3, PORT4_EEPROM_0, PORT4_EEPROM_1, PORT4_EEPROM_2, PORT4_EEPROM_3,
+    PORT5_EEPROM_0, PORT5_EEPROM_1, PORT5_EEPROM_2, PORT5_EEPROM_3, PORT6_EEPROM_0, PORT6_EEPROM_1, PORT6_EEPROM_2, PORT6_EEPROM_3, PORT7_EEPROM_0, PORT7_EEPROM_1, PORT7_EEPROM_2, PORT7_EEPROM_3,
+    PORT8_EEPROM_0, PORT8_EEPROM_1, PORT8_EEPROM_2, PORT8_EEPROM_3, PORT9_EEPROM_0, PORT9_EEPROM_1, PORT9_EEPROM_2, PORT9_EEPROM_3, PORT10_EEPROM_0, PORT10_EEPROM_1, PORT10_EEPROM_2, PORT10_EEPROM_3,
+    PORT11_EEPROM_0, PORT11_EEPROM_1, PORT11_EEPROM_2, PORT11_EEPROM_3, PORT12_EEPROM_0, PORT12_EEPROM_1, PORT12_EEPROM_2, PORT12_EEPROM_3, 
+};
+
+struct fpga_device
+{
+    char __iomem* hw_addr;
+    struct mutex driver_lock;
+    struct device dev;
+};
+
+static u16 mdio_read_result_data;
+static u32 mdec_read_result_data;
+static u8 qsfp_read_result_data;
+
+static void write_port_eeprom_one_byte(struct fpga_device* fpga_dev, u8 port, u8 pos, u8 value);
+static void read_port_eeprom_data(struct fpga_device* fpga_dev, u8 port, u8 *buffer);
+static u8 read_port_eeprom_one_byte(struct fpga_device* fpga_dev, u8 port, u8 pos);
+
+/* =================== local subprogram bodies =================== */
+static u32 t600_fj_mdec_read32(void *addr)
+{
+	u32 value = ioread32(addr);
+	return le32_to_cpu(value);
+}
+
+static void t600_fj_mdec_write32(u32 value, void *addr)
+{
+	u32 data = cpu_to_le32(value);
+	iowrite32(data, addr);
+}
+
+/* =================== The Sysfs Interface Area [START] =================== */
+static ssize_t cpld_version_show(struct device* dev, struct device_attribute* attr, char* buf)
+{
+    struct fpga_device* fpga_dev = dev_get_drvdata(dev);
+    u32 value = 0x00000000;
+
+    mutex_lock(&fpga_dev->driver_lock);
+    value = t600_fj_mdec_read32(fpga_dev->hw_addr + CPLD_VERSION);
+    mutex_unlock(&fpga_dev->driver_lock);
+
+    return sprintf(buf, "0x%08X\n", value);
+}
+
+static ssize_t mdio_read_result(struct device* dev, struct device_attribute* attr, char* buf)
+{
+    return sprintf(buf, "0x%04X\n", mdio_read_result_data);
+} 
+
+static ssize_t mdec_read_result(struct device* dev, struct device_attribute* attr, char* buf)
+{
+    return sprintf(buf, "0x%08X\n", mdec_read_result_data);
+}
+
+static ssize_t read_mdec_eeprom(struct device* dev, struct device_attribute* attr, char* buf)
+{
+    u32 value;
+    char __iomem* mem_addr;
+    char temp[8];
+    char buf1[MDEC_EEPROM_SIZE * 2];
+
+    int i = 0;
+    struct fpga_device* fpga_dev = dev_get_drvdata(dev);
+    mem_addr = fpga_dev->hw_addr;
+
+    memset(buf1, 0, MDEC_EEPROM_SIZE * 2);
+    memset(temp, 0, 8);
+    mutex_lock(&fpga_dev->driver_lock);    
+    mem_addr = fpga_dev->hw_addr + MDEC_EEPROM_ADDR;
+    
+    for(i = 0; i < (MDEC_EEPROM_SIZE / 4); i++)
+    {
+        value = t600_fj_mdec_read32(mem_addr);
+        sprintf(temp, "%08X", value);
+        mem_addr = mem_addr + 0x00000004;
+        strcat(buf1, temp);
+    }
+
+    mutex_unlock(&fpga_dev->driver_lock);
+    return sprintf(buf, "%s\n", buf1);
+}
+
+static ssize_t qsfp_read_result(struct device* dev, struct device_attribute* attr, char* buf)
+{
+    return sprintf(buf, "0x%02X\n", qsfp_read_result_data);
+} 
+
+static ssize_t mdio_action_store(struct device* dev, struct device_attribute* attr, const char* buf, size_t count)
+{
+    u32 mode, page, address, data, status;
+    struct fpga_device* fpga_dev = NULL;
+    int i = 0;
+
+    fpga_dev = dev_get_drvdata(dev);
+
+    if(sscanf(buf, "0x%x 0x%x 0x%x 0x%x",&mode, &page, &address, &data) != 4)
+    {
+        return  - EINVAL;
+    } 
+    
+    printk(KERN_INFO "[DEBUG] mode=%04X, page=%04X, address=%04X, data=%04X\r\n", (u16)mode, (u16)page, (u16)address, (u16)data);
+    
+    if(mode > MDIO_WRITE_MODE)
+    {
+        printk(KERN_INFO "[ERR] mode ERR, mode range is 0X0000 ~0x0001 \r\n");
+        return  - EINVAL;
+    }
+    
+    mutex_lock(&fpga_dev->driver_lock);
+    // Check MDIO busy status
+    for(i = 0; i < MDIO_STATUS_CHK_RETRY_COUNT ; i++)
+    {
+        status = t600_fj_mdec_read32(fpga_dev->hw_addr + BMD_BUS_BUSY); // read MDIO busy status
+        if(status == MDIO_STATUS_BUSY){
+            udelay(10);
+        }
+        else{
+            break;
+        }
+    }
+        
+    // write
+    if(mode == MDIO_WRITE_MODE)
+    {
+        if (page <= 0x000B)
+        {   
+            t600_fj_mdec_write32(((0x0 << 8) | (0x1)), fpga_dev->hw_addr + BMD_BUS_MDIO_SUB_WT_ADD);     // SUB_1 & SUB_2
+            t600_fj_mdec_write32(((page << 16) | (address)), fpga_dev->hw_addr +  BMD_BUS_MDIO_WT_ADD); // set page & address
+            t600_fj_mdec_write32(data, fpga_dev->hw_addr + BMD_BUS_MDIO_WT_DT);      // set write data
+            t600_fj_mdec_write32(MDIO_WRITE_CMD1, fpga_dev->hw_addr + BMD_BUS_ACC_CMD); // set write command
+        }
+        else if(page == 0xFFFF)
+        {
+            t600_fj_mdec_write32(((0x0 << 8) | (0x1)), fpga_dev->hw_addr + BMD_BUS_MDIO_SUB_WT_ADD);     // SUB_1 & SUB_2
+            t600_fj_mdec_write32(((0xFFFF << 16) | (address)), fpga_dev->hw_addr +  BMD_BUS_MDIO_WT_ADD); // set page & address
+            t600_fj_mdec_write32(data, fpga_dev->hw_addr + BMD_BUS_MDIO_WT_DT);      // set write data
+            t600_fj_mdec_write32(MDIO_WRITE_CMD2, fpga_dev->hw_addr + BMD_BUS_ACC_CMD); // set write command
+        }
+        else
+        {
+            return  - EINVAL;   
+        }    
+    }
+    else
+    {
+        
+MDIO_READ_BEGIN:
+    
+        if (page <= 0x000B)
+        {   
+            t600_fj_mdec_write32(((0x0 << 8) | (0x1)), fpga_dev->hw_addr + BMD_BUS_MDIO_SUB_RD_ADD);     // SUB_1 & SUB_2
+            t600_fj_mdec_write32(((page << 16) | (address)), fpga_dev->hw_addr +  BMD_BUS_MDIO_RD_ADD); // set address
+            t600_fj_mdec_write32(MDIO_READ_CMD1, fpga_dev->hw_addr + BMD_BUS_ACC_CMD); // set read command
+        }
+        else if(page == 0xFFFF)
+        {
+            t600_fj_mdec_write32(((0x0 << 8) | (0x1)), fpga_dev->hw_addr + BMD_BUS_MDIO_SUB_RD_ADD);     // SUB_1 & SUB_2
+            t600_fj_mdec_write32(((0xFFFF << 16) | (address)), fpga_dev->hw_addr +  BMD_BUS_MDIO_RD_ADD); // set address
+            t600_fj_mdec_write32(MDIO_READ_CMD2, fpga_dev->hw_addr + BMD_BUS_ACC_CMD); // set read command
+        }
+        else
+        {
+            return  - EINVAL;   
+        }
+        
+        // Check MDIO busy status
+        for(i = 0; i < MDIO_STATUS_CHK_RETRY_COUNT ; i++)
+        {
+            status = t600_fj_mdec_read32(fpga_dev->hw_addr + BMD_BUS_BUSY); // read MDIO busy status
+            if(status == MDIO_STATUS_BUSY){
+                udelay(10);
+            }
+            else{
+                break;
+            }
+        }
+        
+        // Bus Error Check    
+        for(i = 0; i < MDIO_BUS_CHK_RETRY_COUNT ; i++)
+        {
+              // Check bus error bit
+            status = t600_fj_mdec_read32(fpga_dev->hw_addr + BMD_AC_BUS_TAERR);
+            status &= 0x0001;
+              
+            if(status == MDIO_BUS_CHK_OK)
+            {
+                printk(KERN_INFO "[DEBUG] MDIO BUS bus is OK\r\n");
+                  // NOT BUSY
+                  break;
+            }
+            if(i == MDIO_BUS_CHK_RETRY_COUNT -1)
+            {
+                goto MDIO_READ_BEGIN;   
+            }
+            printk(KERN_INFO "[DEBUG] I2C bus busy, retry count =%d\r\n", i);
+        }   
+        // Read data
+        mdio_read_result_data = t600_fj_mdec_read32(fpga_dev->hw_addr + BMD_BUS_MDIO_RD_DT);
+    }
+    
+    mutex_unlock(&fpga_dev->driver_lock);
+    return count;
+}
+
+static ssize_t mdec_action_store(struct device* dev, struct device_attribute* attr, const char* buf, size_t count)
+{
+    u32 mode, address, data;
+    struct fpga_device* fpga_dev = NULL;
+
+    fpga_dev = dev_get_drvdata(dev);
+
+    if(sscanf(buf, "0x%x 0x%x 0x%x",&mode, &address, &data) != 3)
+    {
+        return  - EINVAL;
+    } 
+    
+    printk(KERN_INFO "[DEBUG] mode=%08X, address=%08X, data=%08X\r\n", mode, address, data);
+    
+    if(mode > MDIO_WRITE_MODE)
+    {
+        printk(KERN_INFO "[ERR] mode ERR, mode range is 0X00000000 ~0x00000001 \r\n");
+        return  - EINVAL;
+    }
+    
+    mutex_lock(&fpga_dev->driver_lock);
+        
+    // write
+    if(mode == MDEC_WRITE_MODE)
+    {
+        t600_fj_mdec_write32(data, fpga_dev->hw_addr + address);
+    }
+    else
+    {
+        // Read data
+          mdec_read_result_data = t600_fj_mdec_read32(fpga_dev->hw_addr + address);
+    }
+    
+    mutex_unlock(&fpga_dev->driver_lock);
+    return count;
+}
+
+static ssize_t qsfp_action_store(struct device* dev, struct device_attribute* attr, const char* buf, size_t count)
+{
+    u32 mode, port, address, data;
+    struct fpga_device* fpga_dev = NULL;
+        
+    fpga_dev = dev_get_drvdata(dev);
+
+    if(sscanf(buf, "0x%x 0x%x 0x%x 0x%x",&mode, &port, &address, &data) != 4)
+    {
+        return  - EINVAL;
+    } 
+    
+    printk(KERN_INFO "[DEBUG] mode=%02X, address=%02X, data=%02X\r\n", mode, address, data);
+    
+    if(mode > I2C_WRITE_MODE)
+    {
+        printk(KERN_INFO "[ERR] mode ERR, mode range is 0X00000000 ~0x00000001 \r\n");
+        return  - EINVAL;
+    }
+    
+    mutex_lock(&fpga_dev->driver_lock);
+
+
+    if(mode == I2C_WRITE_MODE)
+    {
+        write_port_eeprom_one_byte(fpga_dev, port, address, data);
+    }
+    else
+    {
+        qsfp_read_result_data = read_port_eeprom_one_byte(fpga_dev, port, address);
+        printk(KERN_INFO "[DEBUG] READ - I2C_READ_DT = %02x\n", qsfp_read_result_data);
+    }
+
+
+    mutex_unlock(&fpga_dev->driver_lock);
+    return count;
+}
+
+static ssize_t read_port_eeprom(struct device* dev, struct device_attribute* attr, char* buf)
+{
+    struct sensor_device_attribute* dev_attr = to_sensor_dev_attr(attr);
+    u8 eerpom_buf[QSFP_EEPROM_SIZE];
+    struct fpga_device* fpga_dev = dev_get_drvdata(dev);
+    
+    memset(eerpom_buf, 0x00, QSFP_EEPROM_SIZE);
+    mutex_lock(&fpga_dev->driver_lock);
+
+    switch(dev_attr->index)
+    {
+
+        case PORT1_EEPROM_0:     // port1, page0
+             write_port_eeprom_one_byte(fpga_dev, PORT1_HEX, POS_127_HEX, 0x00);
+             read_port_eeprom_data(fpga_dev, PORT1_HEX, eerpom_buf);
+             break;
+        case PORT1_EEPROM_1:     // port1, page1
+             write_port_eeprom_one_byte(fpga_dev, PORT1_HEX, POS_127_HEX, 0x01);
+             read_port_eeprom_data(fpga_dev, PORT1_HEX, eerpom_buf);
+             break;
+        case PORT1_EEPROM_2:     // port1, page2
+             write_port_eeprom_one_byte(fpga_dev, PORT1_HEX, POS_127_HEX, 0x02);
+             read_port_eeprom_data(fpga_dev, PORT1_HEX, eerpom_buf);
+             break;
+        case PORT1_EEPROM_3:     // port1, page3
+             write_port_eeprom_one_byte(fpga_dev, PORT1_HEX, POS_127_HEX, 0x03);
+             read_port_eeprom_data(fpga_dev, PORT1_HEX, eerpom_buf);
+             break;
+        case PORT2_EEPROM_0:     // port2, page0
+             write_port_eeprom_one_byte(fpga_dev, PORT2_HEX, POS_127_HEX, 0x00);
+             read_port_eeprom_data(fpga_dev, PORT2_HEX, eerpom_buf);
+             break;
+        case PORT2_EEPROM_1:     // port2, page1
+             write_port_eeprom_one_byte(fpga_dev, PORT2_HEX, POS_127_HEX, 0x01);
+             read_port_eeprom_data(fpga_dev, PORT2_HEX, eerpom_buf);
+             break;
+        case PORT2_EEPROM_2:     // port2, page2
+             write_port_eeprom_one_byte(fpga_dev, PORT2_HEX, POS_127_HEX, 0x02);
+             read_port_eeprom_data(fpga_dev, PORT2_HEX, eerpom_buf);
+             break;
+        case PORT2_EEPROM_3:     // port2, page3
+             write_port_eeprom_one_byte(fpga_dev, PORT2_HEX, POS_127_HEX, 0x03);
+             read_port_eeprom_data(fpga_dev, PORT2_HEX, eerpom_buf);
+             break;
+        case PORT3_EEPROM_0:     // port3, page0
+             write_port_eeprom_one_byte(fpga_dev, PORT3_HEX, POS_127_HEX, 0x00);
+             read_port_eeprom_data(fpga_dev, PORT3_HEX, eerpom_buf);
+             break;
+        case PORT3_EEPROM_1:     // port3, page1
+             write_port_eeprom_one_byte(fpga_dev, PORT3_HEX, POS_127_HEX, 0x01);
+             read_port_eeprom_data(fpga_dev, PORT3_HEX, eerpom_buf);
+             break;
+        case PORT3_EEPROM_2:     // port3, page2
+             write_port_eeprom_one_byte(fpga_dev, PORT3_HEX, POS_127_HEX, 0x02);
+             read_port_eeprom_data(fpga_dev, PORT3_HEX, eerpom_buf);
+             break;
+        case PORT3_EEPROM_3:     // port3, page3
+             write_port_eeprom_one_byte(fpga_dev, PORT3_HEX, POS_127_HEX, 0x03);
+             read_port_eeprom_data(fpga_dev, PORT3_HEX, eerpom_buf);
+             break;
+        case PORT4_EEPROM_0:     // port4, page0
+             write_port_eeprom_one_byte(fpga_dev, PORT4_HEX, POS_127_HEX, 0x00);
+             read_port_eeprom_data(fpga_dev, PORT4_HEX, eerpom_buf);
+             break;
+        case PORT4_EEPROM_1:     // port4, page1
+             write_port_eeprom_one_byte(fpga_dev, PORT4_HEX, POS_127_HEX, 0x01);
+             read_port_eeprom_data(fpga_dev, PORT4_HEX, eerpom_buf);
+             break;
+        case PORT4_EEPROM_2:     // port4, page2
+             write_port_eeprom_one_byte(fpga_dev, PORT4_HEX, POS_127_HEX, 0x02);
+             read_port_eeprom_data(fpga_dev, PORT4_HEX, eerpom_buf);
+             break;
+        case PORT4_EEPROM_3:     // port4, page3
+             write_port_eeprom_one_byte(fpga_dev, PORT4_HEX, POS_127_HEX, 0x03);
+             read_port_eeprom_data(fpga_dev, PORT4_HEX, eerpom_buf);
+             break;
+        case PORT5_EEPROM_0:     // port5, page0
+             write_port_eeprom_one_byte(fpga_dev, PORT5_HEX, POS_127_HEX, 0x00);
+             read_port_eeprom_data(fpga_dev, PORT5_HEX, eerpom_buf);
+             break;
+        case PORT5_EEPROM_1:     // port5, page1
+             write_port_eeprom_one_byte(fpga_dev, PORT5_HEX, POS_127_HEX, 0x01);
+             read_port_eeprom_data(fpga_dev, PORT5_HEX, eerpom_buf);
+             break;
+        case PORT5_EEPROM_2:     // port5, page2
+             write_port_eeprom_one_byte(fpga_dev, PORT5_HEX, POS_127_HEX, 0x02);
+             read_port_eeprom_data(fpga_dev, PORT5_HEX, eerpom_buf);
+             break;
+        case PORT5_EEPROM_3:     // port5, page3
+             write_port_eeprom_one_byte(fpga_dev, PORT5_HEX, POS_127_HEX, 0x03);
+             read_port_eeprom_data(fpga_dev, PORT5_HEX, eerpom_buf);
+             break;
+        case PORT6_EEPROM_0:     // port6, page0
+             write_port_eeprom_one_byte(fpga_dev, PORT6_HEX, POS_127_HEX, 0x00);
+             read_port_eeprom_data(fpga_dev, PORT6_HEX, eerpom_buf);
+             break;
+        case PORT6_EEPROM_1:     // port6, page1
+             write_port_eeprom_one_byte(fpga_dev, PORT6_HEX, POS_127_HEX, 0x01);
+             read_port_eeprom_data(fpga_dev, PORT6_HEX, eerpom_buf);
+             break;
+        case PORT6_EEPROM_2:     // port6, page2
+             write_port_eeprom_one_byte(fpga_dev, PORT6_HEX, POS_127_HEX, 0x02);
+             read_port_eeprom_data(fpga_dev, PORT6_HEX, eerpom_buf);
+             break;
+        case PORT6_EEPROM_3:     // port6, page3
+             write_port_eeprom_one_byte(fpga_dev, PORT6_HEX, POS_127_HEX, 0x03);
+             read_port_eeprom_data(fpga_dev, PORT6_HEX, eerpom_buf);
+             break;
+        case PORT7_EEPROM_0:     // port7, page0
+             write_port_eeprom_one_byte(fpga_dev, PORT7_HEX, POS_127_HEX, 0x00);
+             read_port_eeprom_data(fpga_dev, PORT7_HEX, eerpom_buf);
+             break;
+        case PORT7_EEPROM_1:     // port7, page1
+             write_port_eeprom_one_byte(fpga_dev, PORT7_HEX, POS_127_HEX, 0x01);
+             read_port_eeprom_data(fpga_dev, PORT7_HEX, eerpom_buf);
+             break;
+        case PORT7_EEPROM_2:     // port7, page2
+             write_port_eeprom_one_byte(fpga_dev, PORT7_HEX, POS_127_HEX, 0x02);
+             read_port_eeprom_data(fpga_dev, PORT7_HEX, eerpom_buf);
+             break;
+        case PORT7_EEPROM_3:     // port7, page3
+             write_port_eeprom_one_byte(fpga_dev, PORT7_HEX, POS_127_HEX, 0x03);
+             read_port_eeprom_data(fpga_dev, PORT7_HEX, eerpom_buf);
+             break;
+        case PORT8_EEPROM_0:     // port8, page0
+             write_port_eeprom_one_byte(fpga_dev, PORT8_HEX, POS_127_HEX, 0x00);
+             read_port_eeprom_data(fpga_dev, PORT8_HEX, eerpom_buf);
+             break;
+        case PORT8_EEPROM_1:     // port8, page1
+             write_port_eeprom_one_byte(fpga_dev, PORT8_HEX, POS_127_HEX, 0x01);
+             read_port_eeprom_data(fpga_dev, PORT8_HEX, eerpom_buf);
+             break;
+        case PORT8_EEPROM_2:     // port8, page2
+             write_port_eeprom_one_byte(fpga_dev, PORT8_HEX, POS_127_HEX, 0x02);
+             read_port_eeprom_data(fpga_dev, PORT8_HEX, eerpom_buf);
+             break;
+        case PORT8_EEPROM_3:     // port8, page3
+             write_port_eeprom_one_byte(fpga_dev, PORT8_HEX, POS_127_HEX, 0x03);
+             read_port_eeprom_data(fpga_dev, PORT8_HEX, eerpom_buf);
+             break;
+        case PORT9_EEPROM_0:     // port9, page0
+             write_port_eeprom_one_byte(fpga_dev, PORT9_HEX, POS_127_HEX, 0x00);
+             read_port_eeprom_data(fpga_dev, PORT9_HEX, eerpom_buf);
+             break;
+        case PORT9_EEPROM_1:     // port9, page1
+             write_port_eeprom_one_byte(fpga_dev, PORT9_HEX, POS_127_HEX, 0x01);
+             read_port_eeprom_data(fpga_dev, PORT9_HEX, eerpom_buf);
+             break;
+        case PORT9_EEPROM_2:     // port9, page2
+             write_port_eeprom_one_byte(fpga_dev, PORT9_HEX, POS_127_HEX, 0x02);
+             read_port_eeprom_data(fpga_dev, PORT9_HEX, eerpom_buf);
+             break;
+        case PORT9_EEPROM_3:     // port9, page3
+             write_port_eeprom_one_byte(fpga_dev, PORT9_HEX, POS_127_HEX, 0x03);
+             read_port_eeprom_data(fpga_dev, PORT9_HEX, eerpom_buf);
+             break;
+        case PORT10_EEPROM_0:     // port10, page0
+             write_port_eeprom_one_byte(fpga_dev, PORT10_HEX, POS_127_HEX, 0x00);
+             read_port_eeprom_data(fpga_dev, PORT10_HEX, eerpom_buf);
+             break;
+        case PORT10_EEPROM_1:     // port10, page1
+             write_port_eeprom_one_byte(fpga_dev, PORT10_HEX, POS_127_HEX, 0x01);
+             read_port_eeprom_data(fpga_dev, PORT10_HEX, eerpom_buf);
+             break;
+        case PORT10_EEPROM_2:     // port10, page2
+             write_port_eeprom_one_byte(fpga_dev, PORT10_HEX, POS_127_HEX, 0x02);
+             read_port_eeprom_data(fpga_dev, PORT10_HEX, eerpom_buf);
+             break;
+        case PORT10_EEPROM_3:     // port10, page3
+             write_port_eeprom_one_byte(fpga_dev, PORT10_HEX, POS_127_HEX, 0x03);
+             read_port_eeprom_data(fpga_dev, PORT10_HEX, eerpom_buf);
+             break;
+        case PORT11_EEPROM_0:     // port11, page0
+             write_port_eeprom_one_byte(fpga_dev, PORT11_HEX, POS_127_HEX, 0x00);
+             read_port_eeprom_data(fpga_dev, PORT11_HEX, eerpom_buf);
+             break;
+        case PORT11_EEPROM_1:     // port11, page1
+             write_port_eeprom_one_byte(fpga_dev, PORT11_HEX, POS_127_HEX, 0x01);
+             read_port_eeprom_data(fpga_dev, PORT11_HEX, eerpom_buf);
+             break;
+        case PORT11_EEPROM_2:     // port11, page2
+             write_port_eeprom_one_byte(fpga_dev, PORT11_HEX, POS_127_HEX, 0x02);
+             read_port_eeprom_data(fpga_dev, PORT11_HEX, eerpom_buf);
+             break;
+        case PORT11_EEPROM_3:     // port11, page3
+             write_port_eeprom_one_byte(fpga_dev, PORT11_HEX, POS_127_HEX, 0x03);
+             read_port_eeprom_data(fpga_dev, PORT11_HEX, eerpom_buf);
+             break;
+        case PORT12_EEPROM_0:     // port12, page0
+             write_port_eeprom_one_byte(fpga_dev, PORT12_HEX, POS_127_HEX, 0x00);
+             read_port_eeprom_data(fpga_dev, PORT12_HEX, eerpom_buf);
+             break;
+        case PORT12_EEPROM_1:     // port12, page1
+             write_port_eeprom_one_byte(fpga_dev, PORT12_HEX, POS_127_HEX, 0x01);
+             read_port_eeprom_data(fpga_dev, PORT12_HEX, eerpom_buf);
+             break;
+        case PORT12_EEPROM_2:     // port12, page2
+             write_port_eeprom_one_byte(fpga_dev, PORT12_HEX, POS_127_HEX, 0x02);
+             read_port_eeprom_data(fpga_dev, PORT12_HEX, eerpom_buf);
+             break;
+        case PORT12_EEPROM_3:     // port12, page3
+             write_port_eeprom_one_byte(fpga_dev, PORT12_HEX, POS_127_HEX, 0x03);
+             read_port_eeprom_data(fpga_dev, PORT12_HEX, eerpom_buf);
+             break;
+        default:
+             break;
+    }
+
+    mutex_unlock(&fpga_dev->driver_lock);
+    memcpy(buf, eerpom_buf, QSFP_EEPROM_SIZE);
+    return QSFP_EEPROM_SIZE;
+}
+
+static void write_port_eeprom_one_byte(struct fpga_device* fpga_dev, u8 port, u8 pos, u8 value)
+{
+    u32 set_add, set_dt, status;
+    int i;
+
+    // Set ModSelL. Address is 0x00An0024. Port1:n=0x0~Port12:n=0xB
+    t600_fj_mdec_write32(0x1, fpga_dev->hw_addr + HW_ModSelL + (port << 16));
+
+    for(i = 0; i < I2C_CHK_BUS_BUSY_RETRY_COUNT ; i++)
+    {
+        status = t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_BUSY + (port << 16)); //0x00An0130, n means port
+        if(status == 0)
+        {
+            printk(KERN_INFO "[DEBUG] I2C bus is idle \r\n"); // idle
+              break;
+        }
+        udelay(200);
+        
+        if(i == (I2C_CHK_BUS_BUSY_RETRY_COUNT -1))
+        {
+            printk(KERN_ERR "I2C bus is busy, retry 200 timeout \r\n");
+        }
+        else
+        {
+            printk(KERN_INFO "[DEBUG] I2C bus is busy, retry count =%d\r\n", i + 1);            
+        }
+    }
+
+    for(i = 0; i < I2C_READ_STATUS_RETRY_COUNT ; i++)
+    {
+        // Set address
+        set_add =  (0xA0000005 | (pos << 16));   //0xA0XX0005, XX mean input address 
+        t600_fj_mdec_write32(set_add, fpga_dev->hw_addr + I2C_WRITE_ADD + (port << 16)); //0x00An01D0, n means port
+        set_dt =  (0x00000000 | value);          // 0x000000XX, XX mean input data 
+        t600_fj_mdec_write32(set_dt, fpga_dev->hw_addr + I2C_WRITE_DT + (port << 16)); //
+        // Write Trigger
+        t600_fj_mdec_write32(I2C_ACC_CMD_WRITE, fpga_dev->hw_addr + I2C_ACC_CMD + (port << 16)); //0x00An0134, n means port
+        status = t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_IRQ_ERR_HL + (port << 12));
+        printk(KERN_INFO "[DEBUG] check - I2C_IRQ_ERR_HL status = %08x(Err), count = %d\n", status, i+1);
+        if(status == 0)
+        {
+            printk(KERN_INFO "[DEBUG] check - I2C_IRQ_ERR_HL status = NO Err\n");
+            break;  
+        }
+        if(i == (I2C_READ_STATUS_RETRY_COUNT -1))
+        {
+            printk(KERN_ERR "check - I2C_IRQ_ERR_HL status is err, retry 3 timeout \r\n");
+        }
+        else
+        {
+            printk(KERN_INFO "[DEBUG] check - I2C_IRQ_ERR_HL status is err, retry count =%d\r\n", i+1);         
+        }
+    }
+
+    // Clear ModSelL. Address 0x00An0024. Port1:n=0x0~Port12:n=0xB
+    udelay(500); /* Fixme! We don't know how long should we delay */
+    t600_fj_mdec_write32(0x0, fpga_dev->hw_addr + HW_ModSelL + (port << 16));
+}
+
+static void read_port_eeprom_data(struct fpga_device* fpga_dev, u8 port, u8 *buffer)
+{
+    u8 eeprom_pos;
+    int i = 0;
+    
+    eeprom_pos = 0x00;
+    
+    for(i = 0 ; i < 256 ; i++)
+    {
+        buffer[i] = read_port_eeprom_one_byte(fpga_dev, port, eeprom_pos);
+        eeprom_pos += 0x01;
+    }
+}
+
+static u8 read_port_eeprom_one_byte(struct fpga_device* fpga_dev, u8 port, u8 pos)
+{
+    u32 set_add, status;
+    u8 value;
+    int i, j;
+
+    // Set ModSelL. Address is 0x00An0024. Port1:n=0x0~Port12:n=0xB
+    t600_fj_mdec_write32(0x1, fpga_dev->hw_addr + HW_ModSelL + (port << 16));
+
+    for(i = 0; i < I2C_CHK_BUS_BUSY_RETRY_COUNT ; i++)
+    {
+        status = t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_BUSY + (port << 16)); //0x00An0130, n means port
+        if(status == 0)
+        {
+            printk(KERN_INFO "[DEBUG] I2C bus NOT busy \r\n");
+              // NOT BUSY
+            break;
+        }
+        udelay(200);
+        printk(KERN_INFO "[DEBUG] I2C bus busy, retry count =%d\r\n", i + 1);
+    }
+        
+    for(i = 0; i < I2C_READ_STATUS_RETRY_COUNT ; i++)
+    {
+        // Set address
+        set_add =  (0xA0000005 | (pos << 16));   //0xA0XX0005, XX mean input address 
+        t600_fj_mdec_write32(set_add, fpga_dev->hw_addr + I2C_READ_ADD + (port << 16)); //0x00An0140, n means port
+        // Write Trigger
+        t600_fj_mdec_write32(I2C_ACC_CMD_READ, fpga_dev->hw_addr + I2C_ACC_CMD + (port << 16)); //0x00An0134, n means port
+            
+        for(j = 0; j < I2C_CHK_BUS_BUSY_RETRY_COUNT ; j++)
+        {
+            udelay(200);
+            status = t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_BUSY + (port << 16)); //0x00An0130, n means port
+            if(status == 0)
+            {
+                printk(KERN_INFO "[DEBUG] I2C bus NOT busy \r\n");
+                  // NOT BUSY
+                break;
+            }
+            printk(KERN_INFO "[DEBUG] I2C bus busy, retry count =%d\r\n", j);
+        }
+
+        status = t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_IRQ_ERR_HL + (port << 16)); //0x00An0120, n means port
+        printk(KERN_INFO "[DEBUG] check - I2C_IRQ_ERR_HL status = %08x(Err), count = %d\n", status, i+1);
+        if(status == 0)
+        {
+            printk(KERN_INFO "[DEBUG] check - I2C_IRQ_ERR_HL status = NO Err\n");
+            break;  
+        }
+    }
+    
+    value = (u8)t600_fj_mdec_read32(fpga_dev->hw_addr + I2C_READ_DT + (port << 16)); //0x00An0144, n means port
+
+    // Clear ModSelL. Address 0x00An0024. Port1:n=0x0~Port12:n=0xB
+    t600_fj_mdec_write32(0x0, fpga_dev->hw_addr + HW_ModSelL + (port << 16));
+    return value;   
+}
+
+static SENSOR_DEVICE_ATTR(cpld_version, S_IRUGO, cpld_version_show, NULL, CPLD_VERSION_ATTR);
+static SENSOR_DEVICE_ATTR(dco_mdio_offset, S_IWUSR, NULL, mdio_action_store, DCO_MDIO_OFFSET_ATTR);
+static SENSOR_DEVICE_ATTR(dco_mdio, S_IRUGO, mdio_read_result, NULL, DCO_MDIO_ATTR);
+static SENSOR_DEVICE_ATTR(mdec_offset, S_IWUSR, NULL, mdec_action_store, MDEC_OFFSET_ATTR);
+static SENSOR_DEVICE_ATTR(mdec, S_IRUGO, mdec_read_result, NULL, MDEC_ATTR);
+static SENSOR_DEVICE_ATTR(mdec_eeprom, S_IRUGO, read_mdec_eeprom, NULL, MDEC_EEPROM_ATTR);
+static SENSOR_DEVICE_ATTR(qsfp_offset, S_IWUSR, NULL, qsfp_action_store, QSFP_OFFSET_ATTR);
+static SENSOR_DEVICE_ATTR(qsfp, S_IRUGO, qsfp_read_result, NULL, QSFP_ATTR);
+
+#define DECLARE_PORT1_EEPROM_SENSOR_DEV_ATTR(index) \
+static SENSOR_DEVICE_ATTR(port1_eeprom_##index, S_IRUGO, read_port_eeprom, NULL, PORT1_EEPROM_##index);
+#define DECLARE_PORT1_EEPROM_ATTR(index) &sensor_dev_attr_port1_eeprom_##index.dev_attr.attr
+#define DECLARE_PORT2_EEPROM_SENSOR_DEV_ATTR(index) \
+static SENSOR_DEVICE_ATTR(port2_eeprom_##index, S_IRUGO, read_port_eeprom, NULL, PORT2_EEPROM_##index);
+#define DECLARE_PORT2_EEPROM_ATTR(index) &sensor_dev_attr_port2_eeprom_##index.dev_attr.attr
+#define DECLARE_PORT3_EEPROM_SENSOR_DEV_ATTR(index) \
+static SENSOR_DEVICE_ATTR(port3_eeprom_##index, S_IRUGO, read_port_eeprom, NULL, PORT3_EEPROM_##index);
+#define DECLARE_PORT3_EEPROM_ATTR(index) &sensor_dev_attr_port3_eeprom_##index.dev_attr.attr
+#define DECLARE_PORT4_EEPROM_SENSOR_DEV_ATTR(index) \
+static SENSOR_DEVICE_ATTR(port4_eeprom_##index, S_IRUGO, read_port_eeprom, NULL, PORT4_EEPROM_##index);
+#define DECLARE_PORT4_EEPROM_ATTR(index) &sensor_dev_attr_port4_eeprom_##index.dev_attr.attr
+#define DECLARE_PORT5_EEPROM_SENSOR_DEV_ATTR(index) \
+static SENSOR_DEVICE_ATTR(port5_eeprom_##index, S_IRUGO, read_port_eeprom, NULL, PORT5_EEPROM_##index);
+#define DECLARE_PORT5_EEPROM_ATTR(index) &sensor_dev_attr_port5_eeprom_##index.dev_attr.attr
+#define DECLARE_PORT6_EEPROM_SENSOR_DEV_ATTR(index) \
+static SENSOR_DEVICE_ATTR(port6_eeprom_##index, S_IRUGO, read_port_eeprom, NULL, PORT6_EEPROM_##index);
+#define DECLARE_PORT6_EEPROM_ATTR(index) &sensor_dev_attr_port6_eeprom_##index.dev_attr.attr
+#define DECLARE_PORT7_EEPROM_SENSOR_DEV_ATTR(index) \
+static SENSOR_DEVICE_ATTR(port7_eeprom_##index, S_IRUGO, read_port_eeprom, NULL, PORT7_EEPROM_##index);
+#define DECLARE_PORT7_EEPROM_ATTR(index) &sensor_dev_attr_port7_eeprom_##index.dev_attr.attr
+#define DECLARE_PORT8_EEPROM_SENSOR_DEV_ATTR(index) \
+static SENSOR_DEVICE_ATTR(port8_eeprom_##index, S_IRUGO, read_port_eeprom, NULL, PORT8_EEPROM_##index);
+#define DECLARE_PORT8_EEPROM_ATTR(index) &sensor_dev_attr_port8_eeprom_##index.dev_attr.attr
+#define DECLARE_PORT9_EEPROM_SENSOR_DEV_ATTR(index) \
+static SENSOR_DEVICE_ATTR(port9_eeprom_##index, S_IRUGO, read_port_eeprom, NULL, PORT9_EEPROM_##index);
+#define DECLARE_PORT9_EEPROM_ATTR(index) &sensor_dev_attr_port9_eeprom_##index.dev_attr.attr
+#define DECLARE_PORT10_EEPROM_SENSOR_DEV_ATTR(index) \
+static SENSOR_DEVICE_ATTR(port10_eeprom_##index, S_IRUGO, read_port_eeprom, NULL, PORT4_EEPROM_##index);
+#define DECLARE_PORT10_EEPROM_ATTR(index) &sensor_dev_attr_port10_eeprom_##index.dev_attr.attr
+#define DECLARE_PORT11_EEPROM_SENSOR_DEV_ATTR(index) \
+static SENSOR_DEVICE_ATTR(port11_eeprom_##index, S_IRUGO, read_port_eeprom, NULL, PORT11_EEPROM_##index);
+#define DECLARE_PORT11_EEPROM_ATTR(index) &sensor_dev_attr_port11_eeprom_##index.dev_attr.attr
+#define DECLARE_PORT12_EEPROM_SENSOR_DEV_ATTR(index) \
+static SENSOR_DEVICE_ATTR(port12_eeprom_##index, S_IRUGO, read_port_eeprom, NULL, PORT12_EEPROM_##index);
+#define DECLARE_PORT12_EEPROM_ATTR(index) &sensor_dev_attr_port12_eeprom_##index.dev_attr.attr
+
+DECLARE_PORT1_EEPROM_SENSOR_DEV_ATTR(0);
+DECLARE_PORT1_EEPROM_SENSOR_DEV_ATTR(1);
+DECLARE_PORT1_EEPROM_SENSOR_DEV_ATTR(2);
+DECLARE_PORT1_EEPROM_SENSOR_DEV_ATTR(3);
+DECLARE_PORT2_EEPROM_SENSOR_DEV_ATTR(0);
+DECLARE_PORT2_EEPROM_SENSOR_DEV_ATTR(1);
+DECLARE_PORT2_EEPROM_SENSOR_DEV_ATTR(2);
+DECLARE_PORT2_EEPROM_SENSOR_DEV_ATTR(3);
+DECLARE_PORT3_EEPROM_SENSOR_DEV_ATTR(0);
+DECLARE_PORT3_EEPROM_SENSOR_DEV_ATTR(1);
+DECLARE_PORT3_EEPROM_SENSOR_DEV_ATTR(2);
+DECLARE_PORT3_EEPROM_SENSOR_DEV_ATTR(3);
+DECLARE_PORT4_EEPROM_SENSOR_DEV_ATTR(0);
+DECLARE_PORT4_EEPROM_SENSOR_DEV_ATTR(1);
+DECLARE_PORT4_EEPROM_SENSOR_DEV_ATTR(2);
+DECLARE_PORT4_EEPROM_SENSOR_DEV_ATTR(3);
+DECLARE_PORT5_EEPROM_SENSOR_DEV_ATTR(0);
+DECLARE_PORT5_EEPROM_SENSOR_DEV_ATTR(1);
+DECLARE_PORT5_EEPROM_SENSOR_DEV_ATTR(2);
+DECLARE_PORT5_EEPROM_SENSOR_DEV_ATTR(3);
+DECLARE_PORT6_EEPROM_SENSOR_DEV_ATTR(0);
+DECLARE_PORT6_EEPROM_SENSOR_DEV_ATTR(1);
+DECLARE_PORT6_EEPROM_SENSOR_DEV_ATTR(2);
+DECLARE_PORT6_EEPROM_SENSOR_DEV_ATTR(3);
+DECLARE_PORT7_EEPROM_SENSOR_DEV_ATTR(0);
+DECLARE_PORT7_EEPROM_SENSOR_DEV_ATTR(1);
+DECLARE_PORT7_EEPROM_SENSOR_DEV_ATTR(2);
+DECLARE_PORT7_EEPROM_SENSOR_DEV_ATTR(3);
+DECLARE_PORT8_EEPROM_SENSOR_DEV_ATTR(0);
+DECLARE_PORT8_EEPROM_SENSOR_DEV_ATTR(1);
+DECLARE_PORT8_EEPROM_SENSOR_DEV_ATTR(2);
+DECLARE_PORT8_EEPROM_SENSOR_DEV_ATTR(3);
+DECLARE_PORT9_EEPROM_SENSOR_DEV_ATTR(0);
+DECLARE_PORT9_EEPROM_SENSOR_DEV_ATTR(1);
+DECLARE_PORT9_EEPROM_SENSOR_DEV_ATTR(2);
+DECLARE_PORT9_EEPROM_SENSOR_DEV_ATTR(3);
+DECLARE_PORT10_EEPROM_SENSOR_DEV_ATTR(0);
+DECLARE_PORT10_EEPROM_SENSOR_DEV_ATTR(1);
+DECLARE_PORT10_EEPROM_SENSOR_DEV_ATTR(2);
+DECLARE_PORT10_EEPROM_SENSOR_DEV_ATTR(3);
+DECLARE_PORT11_EEPROM_SENSOR_DEV_ATTR(0);
+DECLARE_PORT11_EEPROM_SENSOR_DEV_ATTR(1);
+DECLARE_PORT11_EEPROM_SENSOR_DEV_ATTR(2);
+DECLARE_PORT11_EEPROM_SENSOR_DEV_ATTR(3);
+DECLARE_PORT12_EEPROM_SENSOR_DEV_ATTR(0);
+DECLARE_PORT12_EEPROM_SENSOR_DEV_ATTR(1);
+DECLARE_PORT12_EEPROM_SENSOR_DEV_ATTR(2);
+DECLARE_PORT12_EEPROM_SENSOR_DEV_ATTR(3);
+
+static struct attribute* sysfs_attributes[] = 
+{
+    &sensor_dev_attr_cpld_version.dev_attr.attr, &sensor_dev_attr_dco_mdio_offset.dev_attr.attr, &sensor_dev_attr_dco_mdio.dev_attr.attr, &sensor_dev_attr_mdec_offset.dev_attr.attr, &sensor_dev_attr_mdec.dev_attr.attr, &sensor_dev_attr_mdec_eeprom.dev_attr.attr, &sensor_dev_attr_qsfp_offset.dev_attr.attr, &sensor_dev_attr_qsfp.dev_attr.attr, DECLARE_PORT1_EEPROM_ATTR(0), DECLARE_PORT1_EEPROM_ATTR(1), DECLARE_PORT1_EEPROM_ATTR(2), DECLARE_PORT1_EEPROM_ATTR(3),
+    DECLARE_PORT2_EEPROM_ATTR(0), DECLARE_PORT2_EEPROM_ATTR(1), DECLARE_PORT2_EEPROM_ATTR(2), DECLARE_PORT2_EEPROM_ATTR(3),DECLARE_PORT3_EEPROM_ATTR(0), DECLARE_PORT3_EEPROM_ATTR(1), DECLARE_PORT3_EEPROM_ATTR(2), DECLARE_PORT3_EEPROM_ATTR(3),DECLARE_PORT4_EEPROM_ATTR(0), DECLARE_PORT4_EEPROM_ATTR(1), DECLARE_PORT4_EEPROM_ATTR(2), DECLARE_PORT4_EEPROM_ATTR(3),
+    DECLARE_PORT5_EEPROM_ATTR(0), DECLARE_PORT5_EEPROM_ATTR(1), DECLARE_PORT5_EEPROM_ATTR(2), DECLARE_PORT5_EEPROM_ATTR(3),DECLARE_PORT6_EEPROM_ATTR(0), DECLARE_PORT6_EEPROM_ATTR(1), DECLARE_PORT6_EEPROM_ATTR(2), DECLARE_PORT6_EEPROM_ATTR(3),DECLARE_PORT7_EEPROM_ATTR(0), DECLARE_PORT7_EEPROM_ATTR(1), DECLARE_PORT7_EEPROM_ATTR(2), DECLARE_PORT7_EEPROM_ATTR(3),
+    DECLARE_PORT8_EEPROM_ATTR(0), DECLARE_PORT8_EEPROM_ATTR(1), DECLARE_PORT8_EEPROM_ATTR(2), DECLARE_PORT8_EEPROM_ATTR(3),DECLARE_PORT9_EEPROM_ATTR(0), DECLARE_PORT9_EEPROM_ATTR(1), DECLARE_PORT9_EEPROM_ATTR(2), DECLARE_PORT9_EEPROM_ATTR(3),DECLARE_PORT10_EEPROM_ATTR(0), DECLARE_PORT10_EEPROM_ATTR(1), DECLARE_PORT10_EEPROM_ATTR(2), DECLARE_PORT10_EEPROM_ATTR(3),
+    DECLARE_PORT11_EEPROM_ATTR(0), DECLARE_PORT11_EEPROM_ATTR(1), DECLARE_PORT11_EEPROM_ATTR(2), DECLARE_PORT11_EEPROM_ATTR(3),DECLARE_PORT12_EEPROM_ATTR(0), DECLARE_PORT12_EEPROM_ATTR(1), DECLARE_PORT12_EEPROM_ATTR(2), DECLARE_PORT12_EEPROM_ATTR(3),NULL, 
+};
+
+static const struct attribute_group sysfs_group = 
+{
+    .attrs = sysfs_attributes, 
+};
+
+/* ==================== The Sysfs Interface Area [END] ==================== */
+
+static int accton_fpga_probe(struct pci_dev* pdev, const struct pci_device_id* dev_id)
+{
+    struct fpga_device* fpga_dev;
+    int pci_dev_busy = 0;
+    int rc =  - EBUSY;
+
+
+    dev_info(&pdev->dev, "%s v%s\n", DRIVER_DESCRIPTION_NAME, DRIVER_VERSION);
+
+    /* Enable pci dev. */
+    rc = pci_enable_device(pdev);
+    if(rc)
+    {
+        dev_err(&pdev->dev, "failed to enable pci device.\r\n");
+        return rc;
+    } 
+
+    /* Set PCI host mastering DMA. */
+    pci_set_master(pdev);
+
+    /* Make pci request regions for this driver. */
+    rc = pci_request_regions(pdev, DRIVER_NAME);
+    if(rc)
+    {
+        pci_dev_busy = 1;
+        goto err_out;
+    }
+
+    pci_intx(pdev, 1);
+
+    fpga_dev = kzalloc(sizeof(*fpga_dev), GFP_KERNEL);
+    if(fpga_dev == NULL)
+    {
+        dev_err(&pdev->dev, "unable to allocate device memory.\r\n");
+        goto err_out_int;
+    }
+    mutex_init(&fpga_dev->driver_lock);
+
+    pci_set_drvdata(pdev, fpga_dev);
+
+    /* Remap the BAR0 address of PCI/PCI-E configuration space. */
+    fpga_dev->hw_addr = pci_ioremap_bar(pdev, 0);
+    if(!fpga_dev->hw_addr)
+    {
+        dev_err(&pdev->dev, "mapping I/O device memory failure.\r\n");
+        rc =  - ENOMEM;
+        goto err_out_free;
+    }
+
+    /* Register sysfs hooks. */
+    rc = sysfs_create_group(&pdev->dev.kobj, &sysfs_group);
+    if(rc)
+    {
+        dev_err(&pdev->dev, "failed to create attrs.\r\n");
+        rc =  - ENOMEM;
+        goto err_out_unmap;
+    }
+
+    dev_dbg(&pdev->dev, "initialization successful.\r\n");
+    return 0;
+
+    err_out_unmap: iounmap(fpga_dev->hw_addr);
+    err_out_free: pci_set_drvdata(pdev, NULL);
+    kfree(fpga_dev);
+    err_out_int: pci_intx(pdev, 0);
+    pci_release_regions(pdev);
+    err_out: if(!pci_dev_busy)
+    {
+        pci_disable_device(pdev);
+    }
+    dev_err(&pdev->dev, "initialization failed.\r\n");
+    return rc;
+}
+
+static void accton_fpga_remove(struct pci_dev* pdev)
+{
+    struct fpga_device* fpga_dev = pci_get_drvdata(pdev);
+
+    sysfs_remove_group(&pdev->dev.kobj, &sysfs_group);
+    pci_set_drvdata(pdev, NULL);
+
+    iounmap(fpga_dev->hw_addr);
+    pci_intx(pdev, 0);
+    pci_release_regions(pdev);
+
+    pci_disable_device(pdev);
+    kfree(fpga_dev);
+} 
+
+static const struct pci_device_id accton_fpga_tbl[] = 
+{
+    {
+        0x10CF, 0x0000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0
+    } ,
+    {
+        0x10CF, 0x0021, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0
+    } , 
+    {
+        0x10CF, 0x0002, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0
+    } ,
+    /* Required last entry. */
+    {
+        0, 
+    }
+};
+
+MODULE_DEVICE_TABLE(pci, accton_fpga_tbl);
+
+static struct pci_driver accton_fpga_driver = 
+{
+    .name = DRIVER_NAME, .id_table = accton_fpga_tbl, .probe = accton_fpga_probe, .remove = accton_fpga_remove, 
+};
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
+    module_pci_driver(accton_fpga_driver);
+#else 
+    static int __init accton_fpga_init(void)
+    {
+        return pci_register_driver(&accton_fpga_driver);
+    }
+
+    static void __exit accton_fpga_exit(void)
+    {
+        pci_unregister_driver(&accton_fpga_driver);
+    }
+
+    module_init(accton_fpga_init);
+    module_exit(accton_fpga_exit);
+#endif 
+
+
+MODULE_AUTHOR("Vincent Wang");
+MODULE_DESCRIPTION(DRIVER_DESCRIPTION_NAME);
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
-- 
1.9.1

